Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program_structure
Rule 1     program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
Rule 2     program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
Rule 3     program_structure -> PROGRAM initiate ID addfun addprog SEMI changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
Rule 4     program_structure -> PROGRAM initiate ID addfun addprog SEMI MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
Rule 5     addprog -> <empty>
Rule 6     initiate -> <empty>
Rule 7     addfun -> <empty>
Rule 8     changescope -> <empty>
Rule 9     changeback -> <empty>
Rule 10    type -> INT
Rule 11    type -> FLOAT
Rule 12    type -> CHAR
Rule 13    declare_var -> VARS multitypes
Rule 14    multitypes -> type addtype COLON multivars SEMI
Rule 15    multitypes -> type addtype COLON multivars SEMI multitypes
Rule 16    addtype -> <empty>
Rule 17    multivars -> ID addvar
Rule 18    multivars -> ID addvar COMMA multivars
Rule 19    multivars -> dimvars addvard
Rule 20    multivars -> dimvars addvard COMMA multivars
Rule 21    dimvars -> ID LBRACK expr RBRACK
Rule 22    addvar -> <empty>
Rule 23    addvard -> <empty>
Rule 24    return_type -> INT
Rule 25    return_type -> FLOAT
Rule 26    return_type -> CHAR
Rule 27    return_type -> VOID
Rule 28    declare_fun -> FUNCTION return_type addtype ID addfun LPAREN RPAREN
Rule 29    declare_fun -> FUNCTION return_type addtype ID addfun LPAREN paramstatus params paramstatus RPAREN
Rule 30    functions -> declare_fun declare_var LCURLY statutes RCURLY endfunc
Rule 31    functions -> declare_fun LCURLY statutes RCURLY endfunc
Rule 32    functions -> declare_fun declare_var LCURLY statutes RCURLY endfunc functions
Rule 33    functions -> declare_fun LCURLY statutes RCURLY endfunc functions
Rule 34    endfunc -> <empty>
Rule 35    paramstatus -> <empty>
Rule 36    params -> type addtype COLON multivars
Rule 37    params -> type addtype COLON multivars SEMI params
Rule 38    statutes -> assign
Rule 39    statutes -> assign statutes
Rule 40    statutes -> call_void
Rule 41    statutes -> call_void statutes
Rule 42    statutes -> returning
Rule 43    statutes -> reading
Rule 44    statutes -> reading statutes
Rule 45    statutes -> writing
Rule 46    statutes -> writing statutes
Rule 47    statutes -> decision
Rule 48    statutes -> decision statutes
Rule 49    statutes -> conditional
Rule 50    statutes -> conditional statutes
Rule 51    statutes -> nonconditional
Rule 52    statutes -> nonconditional statutes
Rule 53    assign -> ID pushid EQUALS exprs assignment SEMI
Rule 54    assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
Rule 55    assignment -> <empty>
Rule 56    call_void -> ID call exprp confirm SEMI
Rule 57    call_void -> ID call LPAREN RPAREN confirm SEMI
Rule 58    call_void -> special2 exprp sconfirm2 SEMI
Rule 59    special2 -> REGRESION
Rule 60    special2 -> PLOT
Rule 61    sconfirm2 -> <empty>
Rule 62    returning -> RETURN LPAREN exprs returnquad RPAREN SEMI
Rule 63    returnquad -> <empty>
Rule 64    reading -> READ LPAREN read_opt RPAREN SEMI
Rule 65    read_opt -> expr readquad
Rule 66    read_opt -> expr readquad COMMA read_opt
Rule 67    readquad -> <empty>
Rule 68    writing -> WRITE LPAREN write_opt RPAREN SEMI
Rule 69    write_opt -> MESSAGE writequad1
Rule 70    write_opt -> MESSAGE writequad1 COMMA write_opt
Rule 71    write_opt -> exprs writequad2
Rule 72    write_opt -> exprs writequad2 COMMA write_opt
Rule 73    writequad1 -> <empty>
Rule 74    writequad2 -> <empty>
Rule 75    decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
Rule 76    decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
Rule 77    ifquad -> <empty>
Rule 78    elsequad -> <empty>
Rule 79    filljump -> <empty>
Rule 80    conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
Rule 81    loopquad -> <empty>
Rule 82    whilequad -> <empty>
Rule 83    endquad -> <empty>
Rule 84    logic -> relation AND relation logicquad
Rule 85    logic -> relation OR relation logicquad
Rule 86    logic -> relation
Rule 87    relation -> exprs GREATER exprs logicquad
Rule 88    relation -> exprs GREATER_EQ exprs logicquad
Rule 89    relation -> exprs LESSER exprs logicquad
Rule 90    relation -> exprs LESSER_EQ exprs logicquad
Rule 91    relation -> exprs COMPARE exprs logicquad
Rule 92    relation -> exprs DIFFERENT exprs logicquad
Rule 93    logicquad -> <empty>
Rule 94    nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
Rule 95    forquad1 -> <empty>
Rule 96    forquad2 -> <empty>
Rule 97    forquad3 -> <empty>
Rule 98    forquad4 -> <empty>
Rule 99    exprs -> expr pams
Rule 100   exprs -> expr pams COMMA exprs
Rule 101   exprs -> exprp pams
Rule 102   exprs -> exprp pams COMMA exprs
Rule 103   exprp -> LPAREN pushop exprs RPAREN popop
Rule 104   popop -> <empty>
Rule 105   expr -> expr PLUS pushop term quad1
Rule 106   expr -> expr MINUS pushop term quad1
Rule 107   expr -> term quad1
Rule 108   term -> term TIMES pushop factor quad2
Rule 109   term -> term DIVIDE pushop factor quad2
Rule 110   term -> factor quad2
Rule 111   quad1 -> <empty>
Rule 112   quad2 -> <empty>
Rule 113   pushop -> <empty>
Rule 114   factor -> C_INT pushint
Rule 115   factor -> MINUS C_INT pushintn
Rule 116   factor -> C_FLOAT pushfloat
Rule 117   factor -> MINUS C_FLOAT pushfloatn
Rule 118   factor -> C_CHAR pushchar
Rule 119   factor -> ID pushid
Rule 120   factor -> ID pushid LBRACK expr RBRACK verif
Rule 121   factor -> ID call LPAREN RPAREN confirm
Rule 122   factor -> ID call exprp confirm
Rule 123   factor -> special1 exprp sconfirm1
Rule 124   special1 -> MEDIA
Rule 125   special1 -> MODA
Rule 126   special1 -> VARIANZA
Rule 127   sconfirm1 -> <empty>
Rule 128   pushid -> <empty>
Rule 129   pushint -> <empty>
Rule 130   pushintn -> <empty>
Rule 131   pushfloat -> <empty>
Rule 132   pushfloatn -> <empty>
Rule 133   pushchar -> <empty>
Rule 134   verif -> <empty>
Rule 135   call -> <empty>
Rule 136   pams -> <empty>
Rule 137   confirm -> <empty>

Terminals, with rules where they appear

AND                  : 84
CHAR                 : 12 26
COLON                : 14 15 36 37
COMMA                : 18 20 66 70 72 100 102
COMPARE              : 91
C_CHAR               : 118
C_FLOAT              : 116 117
C_INT                : 114 115
DIFFERENT            : 92
DIVIDE               : 109
DO                   : 80 94
ELSE                 : 76
EQUALS               : 53 54 94
FLOAT                : 11 25
FOR                  : 94
FUNCTION             : 28 29
GREATER              : 87
GREATER_EQ           : 88
ID                   : 1 2 3 4 17 18 21 28 29 53 54 56 57 119 120 121 122
IF                   : 75 76
INT                  : 10 24
LBRACK               : 21 54 120
LCURLY               : 1 2 3 4 30 31 32 33 75 76 76 80 94
LESSER               : 89
LESSER_EQ            : 90
LPAREN               : 1 2 3 4 28 29 57 62 64 68 75 76 80 103 121
MAIN                 : 1 2 3 4
MEDIA                : 124
MESSAGE              : 69 70
MINUS                : 106 115 117
MODA                 : 125
OR                   : 85
PLOT                 : 60
PLUS                 : 105
PROGRAM              : 1 2 3 4
RBRACK               : 21 54 120
RCURLY               : 1 2 3 4 30 31 32 33 75 76 76 80 94
READ                 : 64
REGRESION            : 59
RETURN               : 62
RPAREN               : 1 2 3 4 28 29 57 62 64 68 75 76 80 103 121
SEMI                 : 1 2 3 4 14 15 37 53 54 56 57 58 62 64 68
THEN                 : 75 76
TIMES                : 108
TO                   : 94
VARIANZA             : 126
VARS                 : 13
VOID                 : 27
WHILE                : 80
WRITE                : 68
error                : 

Nonterminals, with rules where they appear

addfun               : 1 2 3 4 28 29
addprog              : 1 2 3 4
addtype              : 14 15 28 29 36 37
addvar               : 17 18
addvard              : 19 20
assign               : 38 39
assignment           : 53 54
call                 : 56 57 121 122
call_void            : 40 41
changeback           : 1 2 3 4
changescope          : 1 2 3
conditional          : 49 50
confirm              : 56 57 121 122
decision             : 47 48
declare_fun          : 30 31 32 33
declare_var          : 1 2 30 32
dimvars              : 19 20
elsequad             : 76
endfunc              : 1 2 3 4 30 31 32 33
endquad              : 80
expr                 : 21 65 66 99 100 105 106 120
exprp                : 56 58 101 102 122 123
exprs                : 53 54 54 62 71 72 87 87 88 88 89 89 90 90 91 91 92 92 94 94 94 100 102 103
factor               : 108 109 110
filljump             : 75 76
forquad1             : 94
forquad2             : 94
forquad3             : 94
forquad4             : 94
functions            : 1 3 32 33
ifquad               : 75 76
initiate             : 1 2 3 4
logic                : 75 76 80
logicquad            : 84 85 87 88 89 90 91 92
loopquad             : 80
multitypes           : 13 15
multivars            : 14 15 18 20 36 37
nonconditional       : 51 52
pams                 : 99 100 101 102
params               : 29 37
paramstatus          : 29 29
popop                : 103
program_structure    : 0
pushchar             : 118
pushfloat            : 116
pushfloatn           : 117
pushid               : 53 54 119 120
pushint              : 114
pushintn             : 115
pushop               : 103 105 106 108 109
quad1                : 105 106 107
quad2                : 108 109 110
read_opt             : 64 66
reading              : 43 44
readquad             : 65 66
relation             : 84 84 85 85 86
return_type          : 28 29
returning            : 42
returnquad           : 62
sconfirm1            : 123
sconfirm2            : 58
special1             : 123
special2             : 58
statutes             : 1 2 3 4 30 31 32 33 39 41 44 46 48 50 52 75 76 76 80 94
term                 : 105 106 107 108 109
type                 : 14 15 36 37
verif                : 54 120
whilequad            : 80
write_opt            : 68 70 72
writequad1           : 69 70
writequad2           : 71 72
writing              : 45 46

Parsing method: LALR

state 0

    (0) S' -> . program_structure
    (1) program_structure -> . PROGRAM initiate ID addfun addprog SEMI declare_var changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (2) program_structure -> . PROGRAM initiate ID addfun addprog SEMI declare_var changescope MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (3) program_structure -> . PROGRAM initiate ID addfun addprog SEMI changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (4) program_structure -> . PROGRAM initiate ID addfun addprog SEMI MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc

    PROGRAM         shift and go to state 2

    program_structure              shift and go to state 1

state 1

    (0) S' -> program_structure .



state 2

    (1) program_structure -> PROGRAM . initiate ID addfun addprog SEMI declare_var changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (2) program_structure -> PROGRAM . initiate ID addfun addprog SEMI declare_var changescope MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (3) program_structure -> PROGRAM . initiate ID addfun addprog SEMI changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (4) program_structure -> PROGRAM . initiate ID addfun addprog SEMI MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (6) initiate -> .

    ID              reduce using rule 6 (initiate -> .)

    initiate                       shift and go to state 3

state 3

    (1) program_structure -> PROGRAM initiate . ID addfun addprog SEMI declare_var changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (2) program_structure -> PROGRAM initiate . ID addfun addprog SEMI declare_var changescope MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (3) program_structure -> PROGRAM initiate . ID addfun addprog SEMI changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (4) program_structure -> PROGRAM initiate . ID addfun addprog SEMI MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc

    ID              shift and go to state 4


state 4

    (1) program_structure -> PROGRAM initiate ID . addfun addprog SEMI declare_var changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (2) program_structure -> PROGRAM initiate ID . addfun addprog SEMI declare_var changescope MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (3) program_structure -> PROGRAM initiate ID . addfun addprog SEMI changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (4) program_structure -> PROGRAM initiate ID . addfun addprog SEMI MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (7) addfun -> .

    SEMI            reduce using rule 7 (addfun -> .)

    addfun                         shift and go to state 5

state 5

    (1) program_structure -> PROGRAM initiate ID addfun . addprog SEMI declare_var changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (2) program_structure -> PROGRAM initiate ID addfun . addprog SEMI declare_var changescope MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (3) program_structure -> PROGRAM initiate ID addfun . addprog SEMI changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (4) program_structure -> PROGRAM initiate ID addfun . addprog SEMI MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (5) addprog -> .

    SEMI            reduce using rule 5 (addprog -> .)

    addprog                        shift and go to state 6

state 6

    (1) program_structure -> PROGRAM initiate ID addfun addprog . SEMI declare_var changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (2) program_structure -> PROGRAM initiate ID addfun addprog . SEMI declare_var changescope MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (3) program_structure -> PROGRAM initiate ID addfun addprog . SEMI changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (4) program_structure -> PROGRAM initiate ID addfun addprog . SEMI MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc

    SEMI            shift and go to state 7


state 7

    (1) program_structure -> PROGRAM initiate ID addfun addprog SEMI . declare_var changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (2) program_structure -> PROGRAM initiate ID addfun addprog SEMI . declare_var changescope MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (3) program_structure -> PROGRAM initiate ID addfun addprog SEMI . changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (4) program_structure -> PROGRAM initiate ID addfun addprog SEMI . MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (13) declare_var -> . VARS multitypes
    (8) changescope -> .

    MAIN            shift and go to state 10
    VARS            shift and go to state 11
    FUNCTION        reduce using rule 8 (changescope -> .)

    declare_var                    shift and go to state 8
    changescope                    shift and go to state 9

state 8

    (1) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var . changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (2) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var . changescope MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (8) changescope -> .

    MAIN            reduce using rule 8 (changescope -> .)
    FUNCTION        reduce using rule 8 (changescope -> .)

    changescope                    shift and go to state 12

state 9

    (3) program_structure -> PROGRAM initiate ID addfun addprog SEMI changescope . functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (30) functions -> . declare_fun declare_var LCURLY statutes RCURLY endfunc
    (31) functions -> . declare_fun LCURLY statutes RCURLY endfunc
    (32) functions -> . declare_fun declare_var LCURLY statutes RCURLY endfunc functions
    (33) functions -> . declare_fun LCURLY statutes RCURLY endfunc functions
    (28) declare_fun -> . FUNCTION return_type addtype ID addfun LPAREN RPAREN
    (29) declare_fun -> . FUNCTION return_type addtype ID addfun LPAREN paramstatus params paramstatus RPAREN

    FUNCTION        shift and go to state 15

    functions                      shift and go to state 13
    declare_fun                    shift and go to state 14

state 10

    (4) program_structure -> PROGRAM initiate ID addfun addprog SEMI MAIN . changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (9) changeback -> .

    LPAREN          reduce using rule 9 (changeback -> .)

    changeback                     shift and go to state 16

state 11

    (13) declare_var -> VARS . multitypes
    (14) multitypes -> . type addtype COLON multivars SEMI
    (15) multitypes -> . type addtype COLON multivars SEMI multitypes
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . CHAR

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    multitypes                     shift and go to state 17
    type                           shift and go to state 18

state 12

    (1) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope . functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (2) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope . MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (30) functions -> . declare_fun declare_var LCURLY statutes RCURLY endfunc
    (31) functions -> . declare_fun LCURLY statutes RCURLY endfunc
    (32) functions -> . declare_fun declare_var LCURLY statutes RCURLY endfunc functions
    (33) functions -> . declare_fun LCURLY statutes RCURLY endfunc functions
    (28) declare_fun -> . FUNCTION return_type addtype ID addfun LPAREN RPAREN
    (29) declare_fun -> . FUNCTION return_type addtype ID addfun LPAREN paramstatus params paramstatus RPAREN

    MAIN            shift and go to state 23
    FUNCTION        shift and go to state 15

    functions                      shift and go to state 22
    declare_fun                    shift and go to state 14

state 13

    (3) program_structure -> PROGRAM initiate ID addfun addprog SEMI changescope functions . MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc

    MAIN            shift and go to state 24


state 14

    (30) functions -> declare_fun . declare_var LCURLY statutes RCURLY endfunc
    (31) functions -> declare_fun . LCURLY statutes RCURLY endfunc
    (32) functions -> declare_fun . declare_var LCURLY statutes RCURLY endfunc functions
    (33) functions -> declare_fun . LCURLY statutes RCURLY endfunc functions
    (13) declare_var -> . VARS multitypes

    LCURLY          shift and go to state 26
    VARS            shift and go to state 11

    declare_var                    shift and go to state 25

state 15

    (28) declare_fun -> FUNCTION . return_type addtype ID addfun LPAREN RPAREN
    (29) declare_fun -> FUNCTION . return_type addtype ID addfun LPAREN paramstatus params paramstatus RPAREN
    (24) return_type -> . INT
    (25) return_type -> . FLOAT
    (26) return_type -> . CHAR
    (27) return_type -> . VOID

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    CHAR            shift and go to state 30
    VOID            shift and go to state 31

    return_type                    shift and go to state 27

state 16

    (4) program_structure -> PROGRAM initiate ID addfun addprog SEMI MAIN changeback . LPAREN RPAREN LCURLY statutes RCURLY endfunc

    LPAREN          shift and go to state 32


state 17

    (13) declare_var -> VARS multitypes .

    MAIN            reduce using rule 13 (declare_var -> VARS multitypes .)
    FUNCTION        reduce using rule 13 (declare_var -> VARS multitypes .)
    LCURLY          reduce using rule 13 (declare_var -> VARS multitypes .)


state 18

    (14) multitypes -> type . addtype COLON multivars SEMI
    (15) multitypes -> type . addtype COLON multivars SEMI multitypes
    (16) addtype -> .

    COLON           reduce using rule 16 (addtype -> .)

    addtype                        shift and go to state 33

state 19

    (10) type -> INT .

    COLON           reduce using rule 10 (type -> INT .)


state 20

    (11) type -> FLOAT .

    COLON           reduce using rule 11 (type -> FLOAT .)


state 21

    (12) type -> CHAR .

    COLON           reduce using rule 12 (type -> CHAR .)


state 22

    (1) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope functions . MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc

    MAIN            shift and go to state 34


state 23

    (2) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope MAIN . changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (9) changeback -> .

    LPAREN          reduce using rule 9 (changeback -> .)

    changeback                     shift and go to state 35

state 24

    (3) program_structure -> PROGRAM initiate ID addfun addprog SEMI changescope functions MAIN . changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (9) changeback -> .

    LPAREN          reduce using rule 9 (changeback -> .)

    changeback                     shift and go to state 36

state 25

    (30) functions -> declare_fun declare_var . LCURLY statutes RCURLY endfunc
    (32) functions -> declare_fun declare_var . LCURLY statutes RCURLY endfunc functions

    LCURLY          shift and go to state 37


state 26

    (31) functions -> declare_fun LCURLY . statutes RCURLY endfunc
    (33) functions -> declare_fun LCURLY . statutes RCURLY endfunc functions
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    statutes                       shift and go to state 38
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 27

    (28) declare_fun -> FUNCTION return_type . addtype ID addfun LPAREN RPAREN
    (29) declare_fun -> FUNCTION return_type . addtype ID addfun LPAREN paramstatus params paramstatus RPAREN
    (16) addtype -> .

    ID              reduce using rule 16 (addtype -> .)

    addtype                        shift and go to state 57

state 28

    (24) return_type -> INT .

    ID              reduce using rule 24 (return_type -> INT .)


state 29

    (25) return_type -> FLOAT .

    ID              reduce using rule 25 (return_type -> FLOAT .)


state 30

    (26) return_type -> CHAR .

    ID              reduce using rule 26 (return_type -> CHAR .)


state 31

    (27) return_type -> VOID .

    ID              reduce using rule 27 (return_type -> VOID .)


state 32

    (4) program_structure -> PROGRAM initiate ID addfun addprog SEMI MAIN changeback LPAREN . RPAREN LCURLY statutes RCURLY endfunc

    RPAREN          shift and go to state 58


state 33

    (14) multitypes -> type addtype . COLON multivars SEMI
    (15) multitypes -> type addtype . COLON multivars SEMI multitypes

    COLON           shift and go to state 59


state 34

    (1) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope functions MAIN . changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc
    (9) changeback -> .

    LPAREN          reduce using rule 9 (changeback -> .)

    changeback                     shift and go to state 60

state 35

    (2) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope MAIN changeback . LPAREN RPAREN LCURLY statutes RCURLY endfunc

    LPAREN          shift and go to state 61


state 36

    (3) program_structure -> PROGRAM initiate ID addfun addprog SEMI changescope functions MAIN changeback . LPAREN RPAREN LCURLY statutes RCURLY endfunc

    LPAREN          shift and go to state 62


state 37

    (30) functions -> declare_fun declare_var LCURLY . statutes RCURLY endfunc
    (32) functions -> declare_fun declare_var LCURLY . statutes RCURLY endfunc functions
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    statutes                       shift and go to state 63
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 38

    (31) functions -> declare_fun LCURLY statutes . RCURLY endfunc
    (33) functions -> declare_fun LCURLY statutes . RCURLY endfunc functions

    RCURLY          shift and go to state 64


state 39

    (38) statutes -> assign .
    (39) statutes -> assign . statutes
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    RCURLY          reduce using rule 38 (statutes -> assign .)
    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    assign                         shift and go to state 39
    statutes                       shift and go to state 65
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 40

    (40) statutes -> call_void .
    (41) statutes -> call_void . statutes
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    RCURLY          reduce using rule 40 (statutes -> call_void .)
    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    call_void                      shift and go to state 40
    statutes                       shift and go to state 66
    assign                         shift and go to state 39
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 41

    (42) statutes -> returning .

    RCURLY          reduce using rule 42 (statutes -> returning .)


state 42

    (43) statutes -> reading .
    (44) statutes -> reading . statutes
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    RCURLY          reduce using rule 43 (statutes -> reading .)
    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    reading                        shift and go to state 42
    statutes                       shift and go to state 67
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 43

    (45) statutes -> writing .
    (46) statutes -> writing . statutes
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    RCURLY          reduce using rule 45 (statutes -> writing .)
    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    writing                        shift and go to state 43
    statutes                       shift and go to state 68
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 44

    (47) statutes -> decision .
    (48) statutes -> decision . statutes
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    RCURLY          reduce using rule 47 (statutes -> decision .)
    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    decision                       shift and go to state 44
    statutes                       shift and go to state 69
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 45

    (49) statutes -> conditional .
    (50) statutes -> conditional . statutes
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    RCURLY          reduce using rule 49 (statutes -> conditional .)
    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    conditional                    shift and go to state 45
    statutes                       shift and go to state 70
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 46

    (51) statutes -> nonconditional .
    (52) statutes -> nonconditional . statutes
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    RCURLY          reduce using rule 51 (statutes -> nonconditional .)
    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    nonconditional                 shift and go to state 46
    statutes                       shift and go to state 71
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    special2                       shift and go to state 48

state 47

    (53) assign -> ID . pushid EQUALS exprs assignment SEMI
    (54) assign -> ID . pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> ID . call exprp confirm SEMI
    (57) call_void -> ID . call LPAREN RPAREN confirm SEMI
    (128) pushid -> .
    (135) call -> .

    EQUALS          reduce using rule 128 (pushid -> .)
    LBRACK          reduce using rule 128 (pushid -> .)
    LPAREN          reduce using rule 135 (call -> .)

    pushid                         shift and go to state 72
    call                           shift and go to state 73

state 48

    (58) call_void -> special2 . exprp sconfirm2 SEMI
    (103) exprp -> . LPAREN pushop exprs RPAREN popop

    LPAREN          shift and go to state 75

    exprp                          shift and go to state 74

state 49

    (62) returning -> RETURN . LPAREN exprs returnquad RPAREN SEMI

    LPAREN          shift and go to state 76


state 50

    (64) reading -> READ . LPAREN read_opt RPAREN SEMI

    LPAREN          shift and go to state 77


state 51

    (68) writing -> WRITE . LPAREN write_opt RPAREN SEMI

    LPAREN          shift and go to state 78


state 52

    (75) decision -> IF . LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> IF . LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump

    LPAREN          shift and go to state 79


state 53

    (80) conditional -> WHILE . loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (81) loopquad -> .

    LPAREN          reduce using rule 81 (loopquad -> .)

    loopquad                       shift and go to state 80

state 54

    (94) nonconditional -> FOR . exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 81
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 55

    (59) special2 -> REGRESION .

    LPAREN          reduce using rule 59 (special2 -> REGRESION .)


state 56

    (60) special2 -> PLOT .

    LPAREN          reduce using rule 60 (special2 -> PLOT .)


state 57

    (28) declare_fun -> FUNCTION return_type addtype . ID addfun LPAREN RPAREN
    (29) declare_fun -> FUNCTION return_type addtype . ID addfun LPAREN paramstatus params paramstatus RPAREN

    ID              shift and go to state 95


state 58

    (4) program_structure -> PROGRAM initiate ID addfun addprog SEMI MAIN changeback LPAREN RPAREN . LCURLY statutes RCURLY endfunc

    LCURLY          shift and go to state 96


state 59

    (14) multitypes -> type addtype COLON . multivars SEMI
    (15) multitypes -> type addtype COLON . multivars SEMI multitypes
    (17) multivars -> . ID addvar
    (18) multivars -> . ID addvar COMMA multivars
    (19) multivars -> . dimvars addvard
    (20) multivars -> . dimvars addvard COMMA multivars
    (21) dimvars -> . ID LBRACK expr RBRACK

    ID              shift and go to state 98

    multivars                      shift and go to state 97
    dimvars                        shift and go to state 99

state 60

    (1) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope functions MAIN changeback . LPAREN RPAREN LCURLY statutes RCURLY endfunc

    LPAREN          shift and go to state 100


state 61

    (2) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope MAIN changeback LPAREN . RPAREN LCURLY statutes RCURLY endfunc

    RPAREN          shift and go to state 101


state 62

    (3) program_structure -> PROGRAM initiate ID addfun addprog SEMI changescope functions MAIN changeback LPAREN . RPAREN LCURLY statutes RCURLY endfunc

    RPAREN          shift and go to state 102


state 63

    (30) functions -> declare_fun declare_var LCURLY statutes . RCURLY endfunc
    (32) functions -> declare_fun declare_var LCURLY statutes . RCURLY endfunc functions

    RCURLY          shift and go to state 103


state 64

    (31) functions -> declare_fun LCURLY statutes RCURLY . endfunc
    (33) functions -> declare_fun LCURLY statutes RCURLY . endfunc functions
    (34) endfunc -> .

    FUNCTION        reduce using rule 34 (endfunc -> .)
    MAIN            reduce using rule 34 (endfunc -> .)

    endfunc                        shift and go to state 104

state 65

    (39) statutes -> assign statutes .

    RCURLY          reduce using rule 39 (statutes -> assign statutes .)


state 66

    (41) statutes -> call_void statutes .

    RCURLY          reduce using rule 41 (statutes -> call_void statutes .)


state 67

    (44) statutes -> reading statutes .

    RCURLY          reduce using rule 44 (statutes -> reading statutes .)


state 68

    (46) statutes -> writing statutes .

    RCURLY          reduce using rule 46 (statutes -> writing statutes .)


state 69

    (48) statutes -> decision statutes .

    RCURLY          reduce using rule 48 (statutes -> decision statutes .)


state 70

    (50) statutes -> conditional statutes .

    RCURLY          reduce using rule 50 (statutes -> conditional statutes .)


state 71

    (52) statutes -> nonconditional statutes .

    RCURLY          reduce using rule 52 (statutes -> nonconditional statutes .)


state 72

    (53) assign -> ID pushid . EQUALS exprs assignment SEMI
    (54) assign -> ID pushid . LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI

    EQUALS          shift and go to state 105
    LBRACK          shift and go to state 106


state 73

    (56) call_void -> ID call . exprp confirm SEMI
    (57) call_void -> ID call . LPAREN RPAREN confirm SEMI
    (103) exprp -> . LPAREN pushop exprs RPAREN popop

    LPAREN          shift and go to state 108

    exprp                          shift and go to state 107

state 74

    (58) call_void -> special2 exprp . sconfirm2 SEMI
    (61) sconfirm2 -> .

    SEMI            reduce using rule 61 (sconfirm2 -> .)

    sconfirm2                      shift and go to state 109

state 75

    (103) exprp -> LPAREN . pushop exprs RPAREN popop
    (113) pushop -> .

    LPAREN          reduce using rule 113 (pushop -> .)
    C_INT           reduce using rule 113 (pushop -> .)
    MINUS           reduce using rule 113 (pushop -> .)
    C_FLOAT         reduce using rule 113 (pushop -> .)
    C_CHAR          reduce using rule 113 (pushop -> .)
    ID              reduce using rule 113 (pushop -> .)
    MEDIA           reduce using rule 113 (pushop -> .)
    MODA            reduce using rule 113 (pushop -> .)
    VARIANZA        reduce using rule 113 (pushop -> .)

    pushop                         shift and go to state 110

state 76

    (62) returning -> RETURN LPAREN . exprs returnquad RPAREN SEMI
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 111
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 77

    (64) reading -> READ LPAREN . read_opt RPAREN SEMI
    (65) read_opt -> . expr readquad
    (66) read_opt -> . expr readquad COMMA read_opt
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    read_opt                       shift and go to state 112
    expr                           shift and go to state 113
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 78

    (68) writing -> WRITE LPAREN . write_opt RPAREN SEMI
    (69) write_opt -> . MESSAGE writequad1
    (70) write_opt -> . MESSAGE writequad1 COMMA write_opt
    (71) write_opt -> . exprs writequad2
    (72) write_opt -> . exprs writequad2 COMMA write_opt
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    MESSAGE         shift and go to state 115
    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    write_opt                      shift and go to state 114
    exprs                          shift and go to state 116
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 79

    (75) decision -> IF LPAREN . logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> IF LPAREN . logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (84) logic -> . relation AND relation logicquad
    (85) logic -> . relation OR relation logicquad
    (86) logic -> . relation
    (87) relation -> . exprs GREATER exprs logicquad
    (88) relation -> . exprs GREATER_EQ exprs logicquad
    (89) relation -> . exprs LESSER exprs logicquad
    (90) relation -> . exprs LESSER_EQ exprs logicquad
    (91) relation -> . exprs COMPARE exprs logicquad
    (92) relation -> . exprs DIFFERENT exprs logicquad
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    logic                          shift and go to state 117
    relation                       shift and go to state 118
    exprs                          shift and go to state 119
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 80

    (80) conditional -> WHILE loopquad . LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad

    LPAREN          shift and go to state 120


state 81

    (94) nonconditional -> FOR exprs . forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (95) forquad1 -> .

    EQUALS          reduce using rule 95 (forquad1 -> .)

    forquad1                       shift and go to state 121

state 82

    (99) exprs -> expr . pams
    (100) exprs -> expr . pams COMMA exprs
    (105) expr -> expr . PLUS pushop term quad1
    (106) expr -> expr . MINUS pushop term quad1
    (136) pams -> .

    PLUS            shift and go to state 123
    MINUS           shift and go to state 124
    COMMA           reduce using rule 136 (pams -> .)
    EQUALS          reduce using rule 136 (pams -> .)
    RPAREN          reduce using rule 136 (pams -> .)
    GREATER         reduce using rule 136 (pams -> .)
    GREATER_EQ      reduce using rule 136 (pams -> .)
    LESSER          reduce using rule 136 (pams -> .)
    LESSER_EQ       reduce using rule 136 (pams -> .)
    COMPARE         reduce using rule 136 (pams -> .)
    DIFFERENT       reduce using rule 136 (pams -> .)
    SEMI            reduce using rule 136 (pams -> .)
    RBRACK          reduce using rule 136 (pams -> .)
    AND             reduce using rule 136 (pams -> .)
    OR              reduce using rule 136 (pams -> .)
    TO              reduce using rule 136 (pams -> .)
    DO              reduce using rule 136 (pams -> .)

    pams                           shift and go to state 122

state 83

    (101) exprs -> exprp . pams
    (102) exprs -> exprp . pams COMMA exprs
    (136) pams -> .

    COMMA           reduce using rule 136 (pams -> .)
    EQUALS          reduce using rule 136 (pams -> .)
    RPAREN          reduce using rule 136 (pams -> .)
    GREATER         reduce using rule 136 (pams -> .)
    GREATER_EQ      reduce using rule 136 (pams -> .)
    LESSER          reduce using rule 136 (pams -> .)
    LESSER_EQ       reduce using rule 136 (pams -> .)
    COMPARE         reduce using rule 136 (pams -> .)
    DIFFERENT       reduce using rule 136 (pams -> .)
    SEMI            reduce using rule 136 (pams -> .)
    RBRACK          reduce using rule 136 (pams -> .)
    AND             reduce using rule 136 (pams -> .)
    OR              reduce using rule 136 (pams -> .)
    TO              reduce using rule 136 (pams -> .)
    DO              reduce using rule 136 (pams -> .)

    pams                           shift and go to state 125

state 84

    (107) expr -> term . quad1
    (108) term -> term . TIMES pushop factor quad2
    (109) term -> term . DIVIDE pushop factor quad2
    (111) quad1 -> .

    TIMES           shift and go to state 127
    DIVIDE          shift and go to state 128
    PLUS            reduce using rule 111 (quad1 -> .)
    MINUS           reduce using rule 111 (quad1 -> .)
    COMMA           reduce using rule 111 (quad1 -> .)
    EQUALS          reduce using rule 111 (quad1 -> .)
    RPAREN          reduce using rule 111 (quad1 -> .)
    GREATER         reduce using rule 111 (quad1 -> .)
    GREATER_EQ      reduce using rule 111 (quad1 -> .)
    LESSER          reduce using rule 111 (quad1 -> .)
    LESSER_EQ       reduce using rule 111 (quad1 -> .)
    COMPARE         reduce using rule 111 (quad1 -> .)
    DIFFERENT       reduce using rule 111 (quad1 -> .)
    SEMI            reduce using rule 111 (quad1 -> .)
    RBRACK          reduce using rule 111 (quad1 -> .)
    AND             reduce using rule 111 (quad1 -> .)
    OR              reduce using rule 111 (quad1 -> .)
    TO              reduce using rule 111 (quad1 -> .)
    DO              reduce using rule 111 (quad1 -> .)

    quad1                          shift and go to state 126

state 85

    (115) factor -> MINUS . C_INT pushintn
    (117) factor -> MINUS . C_FLOAT pushfloatn

    C_INT           shift and go to state 129
    C_FLOAT         shift and go to state 130


state 86

    (110) term -> factor . quad2
    (112) quad2 -> .

    TIMES           reduce using rule 112 (quad2 -> .)
    DIVIDE          reduce using rule 112 (quad2 -> .)
    PLUS            reduce using rule 112 (quad2 -> .)
    MINUS           reduce using rule 112 (quad2 -> .)
    COMMA           reduce using rule 112 (quad2 -> .)
    EQUALS          reduce using rule 112 (quad2 -> .)
    RPAREN          reduce using rule 112 (quad2 -> .)
    GREATER         reduce using rule 112 (quad2 -> .)
    GREATER_EQ      reduce using rule 112 (quad2 -> .)
    LESSER          reduce using rule 112 (quad2 -> .)
    LESSER_EQ       reduce using rule 112 (quad2 -> .)
    COMPARE         reduce using rule 112 (quad2 -> .)
    DIFFERENT       reduce using rule 112 (quad2 -> .)
    SEMI            reduce using rule 112 (quad2 -> .)
    RBRACK          reduce using rule 112 (quad2 -> .)
    AND             reduce using rule 112 (quad2 -> .)
    OR              reduce using rule 112 (quad2 -> .)
    TO              reduce using rule 112 (quad2 -> .)
    DO              reduce using rule 112 (quad2 -> .)

    quad2                          shift and go to state 131

state 87

    (114) factor -> C_INT . pushint
    (129) pushint -> .

    TIMES           reduce using rule 129 (pushint -> .)
    DIVIDE          reduce using rule 129 (pushint -> .)
    PLUS            reduce using rule 129 (pushint -> .)
    MINUS           reduce using rule 129 (pushint -> .)
    COMMA           reduce using rule 129 (pushint -> .)
    EQUALS          reduce using rule 129 (pushint -> .)
    RPAREN          reduce using rule 129 (pushint -> .)
    GREATER         reduce using rule 129 (pushint -> .)
    GREATER_EQ      reduce using rule 129 (pushint -> .)
    LESSER          reduce using rule 129 (pushint -> .)
    LESSER_EQ       reduce using rule 129 (pushint -> .)
    COMPARE         reduce using rule 129 (pushint -> .)
    DIFFERENT       reduce using rule 129 (pushint -> .)
    SEMI            reduce using rule 129 (pushint -> .)
    RBRACK          reduce using rule 129 (pushint -> .)
    AND             reduce using rule 129 (pushint -> .)
    OR              reduce using rule 129 (pushint -> .)
    TO              reduce using rule 129 (pushint -> .)
    DO              reduce using rule 129 (pushint -> .)

    pushint                        shift and go to state 132

state 88

    (116) factor -> C_FLOAT . pushfloat
    (131) pushfloat -> .

    TIMES           reduce using rule 131 (pushfloat -> .)
    DIVIDE          reduce using rule 131 (pushfloat -> .)
    PLUS            reduce using rule 131 (pushfloat -> .)
    MINUS           reduce using rule 131 (pushfloat -> .)
    COMMA           reduce using rule 131 (pushfloat -> .)
    EQUALS          reduce using rule 131 (pushfloat -> .)
    RPAREN          reduce using rule 131 (pushfloat -> .)
    GREATER         reduce using rule 131 (pushfloat -> .)
    GREATER_EQ      reduce using rule 131 (pushfloat -> .)
    LESSER          reduce using rule 131 (pushfloat -> .)
    LESSER_EQ       reduce using rule 131 (pushfloat -> .)
    COMPARE         reduce using rule 131 (pushfloat -> .)
    DIFFERENT       reduce using rule 131 (pushfloat -> .)
    SEMI            reduce using rule 131 (pushfloat -> .)
    RBRACK          reduce using rule 131 (pushfloat -> .)
    AND             reduce using rule 131 (pushfloat -> .)
    OR              reduce using rule 131 (pushfloat -> .)
    TO              reduce using rule 131 (pushfloat -> .)
    DO              reduce using rule 131 (pushfloat -> .)

    pushfloat                      shift and go to state 133

state 89

    (118) factor -> C_CHAR . pushchar
    (133) pushchar -> .

    TIMES           reduce using rule 133 (pushchar -> .)
    DIVIDE          reduce using rule 133 (pushchar -> .)
    PLUS            reduce using rule 133 (pushchar -> .)
    MINUS           reduce using rule 133 (pushchar -> .)
    COMMA           reduce using rule 133 (pushchar -> .)
    EQUALS          reduce using rule 133 (pushchar -> .)
    RPAREN          reduce using rule 133 (pushchar -> .)
    GREATER         reduce using rule 133 (pushchar -> .)
    GREATER_EQ      reduce using rule 133 (pushchar -> .)
    LESSER          reduce using rule 133 (pushchar -> .)
    LESSER_EQ       reduce using rule 133 (pushchar -> .)
    COMPARE         reduce using rule 133 (pushchar -> .)
    DIFFERENT       reduce using rule 133 (pushchar -> .)
    SEMI            reduce using rule 133 (pushchar -> .)
    RBRACK          reduce using rule 133 (pushchar -> .)
    AND             reduce using rule 133 (pushchar -> .)
    OR              reduce using rule 133 (pushchar -> .)
    TO              reduce using rule 133 (pushchar -> .)
    DO              reduce using rule 133 (pushchar -> .)

    pushchar                       shift and go to state 134

state 90

    (119) factor -> ID . pushid
    (120) factor -> ID . pushid LBRACK expr RBRACK verif
    (121) factor -> ID . call LPAREN RPAREN confirm
    (122) factor -> ID . call exprp confirm
    (128) pushid -> .
    (135) call -> .

    LBRACK          reduce using rule 128 (pushid -> .)
    TIMES           reduce using rule 128 (pushid -> .)
    DIVIDE          reduce using rule 128 (pushid -> .)
    PLUS            reduce using rule 128 (pushid -> .)
    MINUS           reduce using rule 128 (pushid -> .)
    COMMA           reduce using rule 128 (pushid -> .)
    EQUALS          reduce using rule 128 (pushid -> .)
    RPAREN          reduce using rule 128 (pushid -> .)
    GREATER         reduce using rule 128 (pushid -> .)
    GREATER_EQ      reduce using rule 128 (pushid -> .)
    LESSER          reduce using rule 128 (pushid -> .)
    LESSER_EQ       reduce using rule 128 (pushid -> .)
    COMPARE         reduce using rule 128 (pushid -> .)
    DIFFERENT       reduce using rule 128 (pushid -> .)
    SEMI            reduce using rule 128 (pushid -> .)
    RBRACK          reduce using rule 128 (pushid -> .)
    AND             reduce using rule 128 (pushid -> .)
    OR              reduce using rule 128 (pushid -> .)
    TO              reduce using rule 128 (pushid -> .)
    DO              reduce using rule 128 (pushid -> .)
    LPAREN          reduce using rule 135 (call -> .)

    pushid                         shift and go to state 135
    call                           shift and go to state 136

state 91

    (123) factor -> special1 . exprp sconfirm1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop

    LPAREN          shift and go to state 75

    exprp                          shift and go to state 137

state 92

    (124) special1 -> MEDIA .

    LPAREN          reduce using rule 124 (special1 -> MEDIA .)


state 93

    (125) special1 -> MODA .

    LPAREN          reduce using rule 125 (special1 -> MODA .)


state 94

    (126) special1 -> VARIANZA .

    LPAREN          reduce using rule 126 (special1 -> VARIANZA .)


state 95

    (28) declare_fun -> FUNCTION return_type addtype ID . addfun LPAREN RPAREN
    (29) declare_fun -> FUNCTION return_type addtype ID . addfun LPAREN paramstatus params paramstatus RPAREN
    (7) addfun -> .

    LPAREN          reduce using rule 7 (addfun -> .)

    addfun                         shift and go to state 138

state 96

    (4) program_structure -> PROGRAM initiate ID addfun addprog SEMI MAIN changeback LPAREN RPAREN LCURLY . statutes RCURLY endfunc
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    statutes                       shift and go to state 139
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 97

    (14) multitypes -> type addtype COLON multivars . SEMI
    (15) multitypes -> type addtype COLON multivars . SEMI multitypes

    SEMI            shift and go to state 140


state 98

    (17) multivars -> ID . addvar
    (18) multivars -> ID . addvar COMMA multivars
    (21) dimvars -> ID . LBRACK expr RBRACK
    (22) addvar -> .

    LBRACK          shift and go to state 142
    COMMA           reduce using rule 22 (addvar -> .)
    SEMI            reduce using rule 22 (addvar -> .)
    RPAREN          reduce using rule 22 (addvar -> .)

    addvar                         shift and go to state 141

state 99

    (19) multivars -> dimvars . addvard
    (20) multivars -> dimvars . addvard COMMA multivars
    (23) addvard -> .

    COMMA           reduce using rule 23 (addvard -> .)
    SEMI            reduce using rule 23 (addvard -> .)
    RPAREN          reduce using rule 23 (addvard -> .)

    addvard                        shift and go to state 143

state 100

    (1) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope functions MAIN changeback LPAREN . RPAREN LCURLY statutes RCURLY endfunc

    RPAREN          shift and go to state 144


state 101

    (2) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope MAIN changeback LPAREN RPAREN . LCURLY statutes RCURLY endfunc

    LCURLY          shift and go to state 145


state 102

    (3) program_structure -> PROGRAM initiate ID addfun addprog SEMI changescope functions MAIN changeback LPAREN RPAREN . LCURLY statutes RCURLY endfunc

    LCURLY          shift and go to state 146


state 103

    (30) functions -> declare_fun declare_var LCURLY statutes RCURLY . endfunc
    (32) functions -> declare_fun declare_var LCURLY statutes RCURLY . endfunc functions
    (34) endfunc -> .

    FUNCTION        reduce using rule 34 (endfunc -> .)
    MAIN            reduce using rule 34 (endfunc -> .)

    endfunc                        shift and go to state 147

state 104

    (31) functions -> declare_fun LCURLY statutes RCURLY endfunc .
    (33) functions -> declare_fun LCURLY statutes RCURLY endfunc . functions
    (30) functions -> . declare_fun declare_var LCURLY statutes RCURLY endfunc
    (31) functions -> . declare_fun LCURLY statutes RCURLY endfunc
    (32) functions -> . declare_fun declare_var LCURLY statutes RCURLY endfunc functions
    (33) functions -> . declare_fun LCURLY statutes RCURLY endfunc functions
    (28) declare_fun -> . FUNCTION return_type addtype ID addfun LPAREN RPAREN
    (29) declare_fun -> . FUNCTION return_type addtype ID addfun LPAREN paramstatus params paramstatus RPAREN

    MAIN            reduce using rule 31 (functions -> declare_fun LCURLY statutes RCURLY endfunc .)
    FUNCTION        shift and go to state 15

    declare_fun                    shift and go to state 14
    functions                      shift and go to state 148

state 105

    (53) assign -> ID pushid EQUALS . exprs assignment SEMI
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 149
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 106

    (54) assign -> ID pushid LBRACK . exprs RBRACK verif EQUALS exprs assignment SEMI
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 150
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 107

    (56) call_void -> ID call exprp . confirm SEMI
    (137) confirm -> .

    SEMI            reduce using rule 137 (confirm -> .)

    confirm                        shift and go to state 151

state 108

    (57) call_void -> ID call LPAREN . RPAREN confirm SEMI
    (103) exprp -> LPAREN . pushop exprs RPAREN popop
    (113) pushop -> .

    RPAREN          shift and go to state 152
    LPAREN          reduce using rule 113 (pushop -> .)
    C_INT           reduce using rule 113 (pushop -> .)
    MINUS           reduce using rule 113 (pushop -> .)
    C_FLOAT         reduce using rule 113 (pushop -> .)
    C_CHAR          reduce using rule 113 (pushop -> .)
    ID              reduce using rule 113 (pushop -> .)
    MEDIA           reduce using rule 113 (pushop -> .)
    MODA            reduce using rule 113 (pushop -> .)
    VARIANZA        reduce using rule 113 (pushop -> .)

    pushop                         shift and go to state 110

state 109

    (58) call_void -> special2 exprp sconfirm2 . SEMI

    SEMI            shift and go to state 153


state 110

    (103) exprp -> LPAREN pushop . exprs RPAREN popop
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 154
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 111

    (62) returning -> RETURN LPAREN exprs . returnquad RPAREN SEMI
    (63) returnquad -> .

    RPAREN          reduce using rule 63 (returnquad -> .)

    returnquad                     shift and go to state 155

state 112

    (64) reading -> READ LPAREN read_opt . RPAREN SEMI

    RPAREN          shift and go to state 156


state 113

    (65) read_opt -> expr . readquad
    (66) read_opt -> expr . readquad COMMA read_opt
    (105) expr -> expr . PLUS pushop term quad1
    (106) expr -> expr . MINUS pushop term quad1
    (67) readquad -> .

    PLUS            shift and go to state 123
    MINUS           shift and go to state 124
    COMMA           reduce using rule 67 (readquad -> .)
    RPAREN          reduce using rule 67 (readquad -> .)

    readquad                       shift and go to state 157

state 114

    (68) writing -> WRITE LPAREN write_opt . RPAREN SEMI

    RPAREN          shift and go to state 158


state 115

    (69) write_opt -> MESSAGE . writequad1
    (70) write_opt -> MESSAGE . writequad1 COMMA write_opt
    (73) writequad1 -> .

    COMMA           reduce using rule 73 (writequad1 -> .)
    RPAREN          reduce using rule 73 (writequad1 -> .)

    writequad1                     shift and go to state 159

state 116

    (71) write_opt -> exprs . writequad2
    (72) write_opt -> exprs . writequad2 COMMA write_opt
    (74) writequad2 -> .

    COMMA           reduce using rule 74 (writequad2 -> .)
    RPAREN          reduce using rule 74 (writequad2 -> .)

    writequad2                     shift and go to state 160

state 117

    (75) decision -> IF LPAREN logic . RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> IF LPAREN logic . RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump

    RPAREN          shift and go to state 161


state 118

    (84) logic -> relation . AND relation logicquad
    (85) logic -> relation . OR relation logicquad
    (86) logic -> relation .

    AND             shift and go to state 162
    OR              shift and go to state 163
    RPAREN          reduce using rule 86 (logic -> relation .)


state 119

    (87) relation -> exprs . GREATER exprs logicquad
    (88) relation -> exprs . GREATER_EQ exprs logicquad
    (89) relation -> exprs . LESSER exprs logicquad
    (90) relation -> exprs . LESSER_EQ exprs logicquad
    (91) relation -> exprs . COMPARE exprs logicquad
    (92) relation -> exprs . DIFFERENT exprs logicquad

    GREATER         shift and go to state 164
    GREATER_EQ      shift and go to state 165
    LESSER          shift and go to state 166
    LESSER_EQ       shift and go to state 167
    COMPARE         shift and go to state 168
    DIFFERENT       shift and go to state 169


state 120

    (80) conditional -> WHILE loopquad LPAREN . logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (84) logic -> . relation AND relation logicquad
    (85) logic -> . relation OR relation logicquad
    (86) logic -> . relation
    (87) relation -> . exprs GREATER exprs logicquad
    (88) relation -> . exprs GREATER_EQ exprs logicquad
    (89) relation -> . exprs LESSER exprs logicquad
    (90) relation -> . exprs LESSER_EQ exprs logicquad
    (91) relation -> . exprs COMPARE exprs logicquad
    (92) relation -> . exprs DIFFERENT exprs logicquad
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    logic                          shift and go to state 170
    relation                       shift and go to state 118
    exprs                          shift and go to state 119
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 121

    (94) nonconditional -> FOR exprs forquad1 . EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4

    EQUALS          shift and go to state 171


state 122

    (99) exprs -> expr pams .
    (100) exprs -> expr pams . COMMA exprs

  ! shift/reduce conflict for COMMA resolved as shift
    EQUALS          reduce using rule 99 (exprs -> expr pams .)
    RPAREN          reduce using rule 99 (exprs -> expr pams .)
    GREATER         reduce using rule 99 (exprs -> expr pams .)
    GREATER_EQ      reduce using rule 99 (exprs -> expr pams .)
    LESSER          reduce using rule 99 (exprs -> expr pams .)
    LESSER_EQ       reduce using rule 99 (exprs -> expr pams .)
    COMPARE         reduce using rule 99 (exprs -> expr pams .)
    DIFFERENT       reduce using rule 99 (exprs -> expr pams .)
    SEMI            reduce using rule 99 (exprs -> expr pams .)
    RBRACK          reduce using rule 99 (exprs -> expr pams .)
    AND             reduce using rule 99 (exprs -> expr pams .)
    OR              reduce using rule 99 (exprs -> expr pams .)
    TO              reduce using rule 99 (exprs -> expr pams .)
    DO              reduce using rule 99 (exprs -> expr pams .)
    COMMA           shift and go to state 172

  ! COMMA           [ reduce using rule 99 (exprs -> expr pams .) ]


state 123

    (105) expr -> expr PLUS . pushop term quad1
    (113) pushop -> .

    C_INT           reduce using rule 113 (pushop -> .)
    MINUS           reduce using rule 113 (pushop -> .)
    C_FLOAT         reduce using rule 113 (pushop -> .)
    C_CHAR          reduce using rule 113 (pushop -> .)
    ID              reduce using rule 113 (pushop -> .)
    MEDIA           reduce using rule 113 (pushop -> .)
    MODA            reduce using rule 113 (pushop -> .)
    VARIANZA        reduce using rule 113 (pushop -> .)

    pushop                         shift and go to state 173

state 124

    (106) expr -> expr MINUS . pushop term quad1
    (113) pushop -> .

    C_INT           reduce using rule 113 (pushop -> .)
    MINUS           reduce using rule 113 (pushop -> .)
    C_FLOAT         reduce using rule 113 (pushop -> .)
    C_CHAR          reduce using rule 113 (pushop -> .)
    ID              reduce using rule 113 (pushop -> .)
    MEDIA           reduce using rule 113 (pushop -> .)
    MODA            reduce using rule 113 (pushop -> .)
    VARIANZA        reduce using rule 113 (pushop -> .)

    pushop                         shift and go to state 174

state 125

    (101) exprs -> exprp pams .
    (102) exprs -> exprp pams . COMMA exprs

  ! shift/reduce conflict for COMMA resolved as shift
    EQUALS          reduce using rule 101 (exprs -> exprp pams .)
    RPAREN          reduce using rule 101 (exprs -> exprp pams .)
    GREATER         reduce using rule 101 (exprs -> exprp pams .)
    GREATER_EQ      reduce using rule 101 (exprs -> exprp pams .)
    LESSER          reduce using rule 101 (exprs -> exprp pams .)
    LESSER_EQ       reduce using rule 101 (exprs -> exprp pams .)
    COMPARE         reduce using rule 101 (exprs -> exprp pams .)
    DIFFERENT       reduce using rule 101 (exprs -> exprp pams .)
    SEMI            reduce using rule 101 (exprs -> exprp pams .)
    RBRACK          reduce using rule 101 (exprs -> exprp pams .)
    AND             reduce using rule 101 (exprs -> exprp pams .)
    OR              reduce using rule 101 (exprs -> exprp pams .)
    TO              reduce using rule 101 (exprs -> exprp pams .)
    DO              reduce using rule 101 (exprs -> exprp pams .)
    COMMA           shift and go to state 175

  ! COMMA           [ reduce using rule 101 (exprs -> exprp pams .) ]


state 126

    (107) expr -> term quad1 .

    PLUS            reduce using rule 107 (expr -> term quad1 .)
    MINUS           reduce using rule 107 (expr -> term quad1 .)
    COMMA           reduce using rule 107 (expr -> term quad1 .)
    EQUALS          reduce using rule 107 (expr -> term quad1 .)
    RPAREN          reduce using rule 107 (expr -> term quad1 .)
    GREATER         reduce using rule 107 (expr -> term quad1 .)
    GREATER_EQ      reduce using rule 107 (expr -> term quad1 .)
    LESSER          reduce using rule 107 (expr -> term quad1 .)
    LESSER_EQ       reduce using rule 107 (expr -> term quad1 .)
    COMPARE         reduce using rule 107 (expr -> term quad1 .)
    DIFFERENT       reduce using rule 107 (expr -> term quad1 .)
    SEMI            reduce using rule 107 (expr -> term quad1 .)
    RBRACK          reduce using rule 107 (expr -> term quad1 .)
    AND             reduce using rule 107 (expr -> term quad1 .)
    OR              reduce using rule 107 (expr -> term quad1 .)
    TO              reduce using rule 107 (expr -> term quad1 .)
    DO              reduce using rule 107 (expr -> term quad1 .)


state 127

    (108) term -> term TIMES . pushop factor quad2
    (113) pushop -> .

    C_INT           reduce using rule 113 (pushop -> .)
    MINUS           reduce using rule 113 (pushop -> .)
    C_FLOAT         reduce using rule 113 (pushop -> .)
    C_CHAR          reduce using rule 113 (pushop -> .)
    ID              reduce using rule 113 (pushop -> .)
    MEDIA           reduce using rule 113 (pushop -> .)
    MODA            reduce using rule 113 (pushop -> .)
    VARIANZA        reduce using rule 113 (pushop -> .)

    pushop                         shift and go to state 176

state 128

    (109) term -> term DIVIDE . pushop factor quad2
    (113) pushop -> .

    C_INT           reduce using rule 113 (pushop -> .)
    MINUS           reduce using rule 113 (pushop -> .)
    C_FLOAT         reduce using rule 113 (pushop -> .)
    C_CHAR          reduce using rule 113 (pushop -> .)
    ID              reduce using rule 113 (pushop -> .)
    MEDIA           reduce using rule 113 (pushop -> .)
    MODA            reduce using rule 113 (pushop -> .)
    VARIANZA        reduce using rule 113 (pushop -> .)

    pushop                         shift and go to state 177

state 129

    (115) factor -> MINUS C_INT . pushintn
    (130) pushintn -> .

    TIMES           reduce using rule 130 (pushintn -> .)
    DIVIDE          reduce using rule 130 (pushintn -> .)
    PLUS            reduce using rule 130 (pushintn -> .)
    MINUS           reduce using rule 130 (pushintn -> .)
    COMMA           reduce using rule 130 (pushintn -> .)
    EQUALS          reduce using rule 130 (pushintn -> .)
    RPAREN          reduce using rule 130 (pushintn -> .)
    GREATER         reduce using rule 130 (pushintn -> .)
    GREATER_EQ      reduce using rule 130 (pushintn -> .)
    LESSER          reduce using rule 130 (pushintn -> .)
    LESSER_EQ       reduce using rule 130 (pushintn -> .)
    COMPARE         reduce using rule 130 (pushintn -> .)
    DIFFERENT       reduce using rule 130 (pushintn -> .)
    SEMI            reduce using rule 130 (pushintn -> .)
    RBRACK          reduce using rule 130 (pushintn -> .)
    AND             reduce using rule 130 (pushintn -> .)
    OR              reduce using rule 130 (pushintn -> .)
    TO              reduce using rule 130 (pushintn -> .)
    DO              reduce using rule 130 (pushintn -> .)

    pushintn                       shift and go to state 178

state 130

    (117) factor -> MINUS C_FLOAT . pushfloatn
    (132) pushfloatn -> .

    TIMES           reduce using rule 132 (pushfloatn -> .)
    DIVIDE          reduce using rule 132 (pushfloatn -> .)
    PLUS            reduce using rule 132 (pushfloatn -> .)
    MINUS           reduce using rule 132 (pushfloatn -> .)
    COMMA           reduce using rule 132 (pushfloatn -> .)
    EQUALS          reduce using rule 132 (pushfloatn -> .)
    RPAREN          reduce using rule 132 (pushfloatn -> .)
    GREATER         reduce using rule 132 (pushfloatn -> .)
    GREATER_EQ      reduce using rule 132 (pushfloatn -> .)
    LESSER          reduce using rule 132 (pushfloatn -> .)
    LESSER_EQ       reduce using rule 132 (pushfloatn -> .)
    COMPARE         reduce using rule 132 (pushfloatn -> .)
    DIFFERENT       reduce using rule 132 (pushfloatn -> .)
    SEMI            reduce using rule 132 (pushfloatn -> .)
    RBRACK          reduce using rule 132 (pushfloatn -> .)
    AND             reduce using rule 132 (pushfloatn -> .)
    OR              reduce using rule 132 (pushfloatn -> .)
    TO              reduce using rule 132 (pushfloatn -> .)
    DO              reduce using rule 132 (pushfloatn -> .)

    pushfloatn                     shift and go to state 179

state 131

    (110) term -> factor quad2 .

    TIMES           reduce using rule 110 (term -> factor quad2 .)
    DIVIDE          reduce using rule 110 (term -> factor quad2 .)
    PLUS            reduce using rule 110 (term -> factor quad2 .)
    MINUS           reduce using rule 110 (term -> factor quad2 .)
    COMMA           reduce using rule 110 (term -> factor quad2 .)
    EQUALS          reduce using rule 110 (term -> factor quad2 .)
    RPAREN          reduce using rule 110 (term -> factor quad2 .)
    GREATER         reduce using rule 110 (term -> factor quad2 .)
    GREATER_EQ      reduce using rule 110 (term -> factor quad2 .)
    LESSER          reduce using rule 110 (term -> factor quad2 .)
    LESSER_EQ       reduce using rule 110 (term -> factor quad2 .)
    COMPARE         reduce using rule 110 (term -> factor quad2 .)
    DIFFERENT       reduce using rule 110 (term -> factor quad2 .)
    SEMI            reduce using rule 110 (term -> factor quad2 .)
    RBRACK          reduce using rule 110 (term -> factor quad2 .)
    AND             reduce using rule 110 (term -> factor quad2 .)
    OR              reduce using rule 110 (term -> factor quad2 .)
    TO              reduce using rule 110 (term -> factor quad2 .)
    DO              reduce using rule 110 (term -> factor quad2 .)


state 132

    (114) factor -> C_INT pushint .

    TIMES           reduce using rule 114 (factor -> C_INT pushint .)
    DIVIDE          reduce using rule 114 (factor -> C_INT pushint .)
    PLUS            reduce using rule 114 (factor -> C_INT pushint .)
    MINUS           reduce using rule 114 (factor -> C_INT pushint .)
    COMMA           reduce using rule 114 (factor -> C_INT pushint .)
    EQUALS          reduce using rule 114 (factor -> C_INT pushint .)
    RPAREN          reduce using rule 114 (factor -> C_INT pushint .)
    GREATER         reduce using rule 114 (factor -> C_INT pushint .)
    GREATER_EQ      reduce using rule 114 (factor -> C_INT pushint .)
    LESSER          reduce using rule 114 (factor -> C_INT pushint .)
    LESSER_EQ       reduce using rule 114 (factor -> C_INT pushint .)
    COMPARE         reduce using rule 114 (factor -> C_INT pushint .)
    DIFFERENT       reduce using rule 114 (factor -> C_INT pushint .)
    SEMI            reduce using rule 114 (factor -> C_INT pushint .)
    RBRACK          reduce using rule 114 (factor -> C_INT pushint .)
    AND             reduce using rule 114 (factor -> C_INT pushint .)
    OR              reduce using rule 114 (factor -> C_INT pushint .)
    TO              reduce using rule 114 (factor -> C_INT pushint .)
    DO              reduce using rule 114 (factor -> C_INT pushint .)


state 133

    (116) factor -> C_FLOAT pushfloat .

    TIMES           reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    DIVIDE          reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    PLUS            reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    MINUS           reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    COMMA           reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    EQUALS          reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    RPAREN          reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    GREATER         reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    GREATER_EQ      reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    LESSER          reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    LESSER_EQ       reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    COMPARE         reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    DIFFERENT       reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    SEMI            reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    RBRACK          reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    AND             reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    OR              reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    TO              reduce using rule 116 (factor -> C_FLOAT pushfloat .)
    DO              reduce using rule 116 (factor -> C_FLOAT pushfloat .)


state 134

    (118) factor -> C_CHAR pushchar .

    TIMES           reduce using rule 118 (factor -> C_CHAR pushchar .)
    DIVIDE          reduce using rule 118 (factor -> C_CHAR pushchar .)
    PLUS            reduce using rule 118 (factor -> C_CHAR pushchar .)
    MINUS           reduce using rule 118 (factor -> C_CHAR pushchar .)
    COMMA           reduce using rule 118 (factor -> C_CHAR pushchar .)
    EQUALS          reduce using rule 118 (factor -> C_CHAR pushchar .)
    RPAREN          reduce using rule 118 (factor -> C_CHAR pushchar .)
    GREATER         reduce using rule 118 (factor -> C_CHAR pushchar .)
    GREATER_EQ      reduce using rule 118 (factor -> C_CHAR pushchar .)
    LESSER          reduce using rule 118 (factor -> C_CHAR pushchar .)
    LESSER_EQ       reduce using rule 118 (factor -> C_CHAR pushchar .)
    COMPARE         reduce using rule 118 (factor -> C_CHAR pushchar .)
    DIFFERENT       reduce using rule 118 (factor -> C_CHAR pushchar .)
    SEMI            reduce using rule 118 (factor -> C_CHAR pushchar .)
    RBRACK          reduce using rule 118 (factor -> C_CHAR pushchar .)
    AND             reduce using rule 118 (factor -> C_CHAR pushchar .)
    OR              reduce using rule 118 (factor -> C_CHAR pushchar .)
    TO              reduce using rule 118 (factor -> C_CHAR pushchar .)
    DO              reduce using rule 118 (factor -> C_CHAR pushchar .)


state 135

    (119) factor -> ID pushid .
    (120) factor -> ID pushid . LBRACK expr RBRACK verif

    TIMES           reduce using rule 119 (factor -> ID pushid .)
    DIVIDE          reduce using rule 119 (factor -> ID pushid .)
    PLUS            reduce using rule 119 (factor -> ID pushid .)
    MINUS           reduce using rule 119 (factor -> ID pushid .)
    COMMA           reduce using rule 119 (factor -> ID pushid .)
    EQUALS          reduce using rule 119 (factor -> ID pushid .)
    RPAREN          reduce using rule 119 (factor -> ID pushid .)
    GREATER         reduce using rule 119 (factor -> ID pushid .)
    GREATER_EQ      reduce using rule 119 (factor -> ID pushid .)
    LESSER          reduce using rule 119 (factor -> ID pushid .)
    LESSER_EQ       reduce using rule 119 (factor -> ID pushid .)
    COMPARE         reduce using rule 119 (factor -> ID pushid .)
    DIFFERENT       reduce using rule 119 (factor -> ID pushid .)
    SEMI            reduce using rule 119 (factor -> ID pushid .)
    RBRACK          reduce using rule 119 (factor -> ID pushid .)
    AND             reduce using rule 119 (factor -> ID pushid .)
    OR              reduce using rule 119 (factor -> ID pushid .)
    TO              reduce using rule 119 (factor -> ID pushid .)
    DO              reduce using rule 119 (factor -> ID pushid .)
    LBRACK          shift and go to state 180


state 136

    (121) factor -> ID call . LPAREN RPAREN confirm
    (122) factor -> ID call . exprp confirm
    (103) exprp -> . LPAREN pushop exprs RPAREN popop

    LPAREN          shift and go to state 181

    exprp                          shift and go to state 182

state 137

    (123) factor -> special1 exprp . sconfirm1
    (127) sconfirm1 -> .

    TIMES           reduce using rule 127 (sconfirm1 -> .)
    DIVIDE          reduce using rule 127 (sconfirm1 -> .)
    PLUS            reduce using rule 127 (sconfirm1 -> .)
    MINUS           reduce using rule 127 (sconfirm1 -> .)
    COMMA           reduce using rule 127 (sconfirm1 -> .)
    EQUALS          reduce using rule 127 (sconfirm1 -> .)
    RPAREN          reduce using rule 127 (sconfirm1 -> .)
    GREATER         reduce using rule 127 (sconfirm1 -> .)
    GREATER_EQ      reduce using rule 127 (sconfirm1 -> .)
    LESSER          reduce using rule 127 (sconfirm1 -> .)
    LESSER_EQ       reduce using rule 127 (sconfirm1 -> .)
    COMPARE         reduce using rule 127 (sconfirm1 -> .)
    DIFFERENT       reduce using rule 127 (sconfirm1 -> .)
    SEMI            reduce using rule 127 (sconfirm1 -> .)
    RBRACK          reduce using rule 127 (sconfirm1 -> .)
    AND             reduce using rule 127 (sconfirm1 -> .)
    OR              reduce using rule 127 (sconfirm1 -> .)
    TO              reduce using rule 127 (sconfirm1 -> .)
    DO              reduce using rule 127 (sconfirm1 -> .)

    sconfirm1                      shift and go to state 183

state 138

    (28) declare_fun -> FUNCTION return_type addtype ID addfun . LPAREN RPAREN
    (29) declare_fun -> FUNCTION return_type addtype ID addfun . LPAREN paramstatus params paramstatus RPAREN

    LPAREN          shift and go to state 184


state 139

    (4) program_structure -> PROGRAM initiate ID addfun addprog SEMI MAIN changeback LPAREN RPAREN LCURLY statutes . RCURLY endfunc

    RCURLY          shift and go to state 185


state 140

    (14) multitypes -> type addtype COLON multivars SEMI .
    (15) multitypes -> type addtype COLON multivars SEMI . multitypes
    (14) multitypes -> . type addtype COLON multivars SEMI
    (15) multitypes -> . type addtype COLON multivars SEMI multitypes
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . CHAR

    MAIN            reduce using rule 14 (multitypes -> type addtype COLON multivars SEMI .)
    FUNCTION        reduce using rule 14 (multitypes -> type addtype COLON multivars SEMI .)
    LCURLY          reduce using rule 14 (multitypes -> type addtype COLON multivars SEMI .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    type                           shift and go to state 18
    multitypes                     shift and go to state 186

state 141

    (17) multivars -> ID addvar .
    (18) multivars -> ID addvar . COMMA multivars

    SEMI            reduce using rule 17 (multivars -> ID addvar .)
    RPAREN          reduce using rule 17 (multivars -> ID addvar .)
    COMMA           shift and go to state 187


state 142

    (21) dimvars -> ID LBRACK . expr RBRACK
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    expr                           shift and go to state 188
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 143

    (19) multivars -> dimvars addvard .
    (20) multivars -> dimvars addvard . COMMA multivars

    SEMI            reduce using rule 19 (multivars -> dimvars addvard .)
    RPAREN          reduce using rule 19 (multivars -> dimvars addvard .)
    COMMA           shift and go to state 189


state 144

    (1) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope functions MAIN changeback LPAREN RPAREN . LCURLY statutes RCURLY endfunc

    LCURLY          shift and go to state 190


state 145

    (2) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope MAIN changeback LPAREN RPAREN LCURLY . statutes RCURLY endfunc
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    statutes                       shift and go to state 191
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 146

    (3) program_structure -> PROGRAM initiate ID addfun addprog SEMI changescope functions MAIN changeback LPAREN RPAREN LCURLY . statutes RCURLY endfunc
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    statutes                       shift and go to state 192
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 147

    (30) functions -> declare_fun declare_var LCURLY statutes RCURLY endfunc .
    (32) functions -> declare_fun declare_var LCURLY statutes RCURLY endfunc . functions
    (30) functions -> . declare_fun declare_var LCURLY statutes RCURLY endfunc
    (31) functions -> . declare_fun LCURLY statutes RCURLY endfunc
    (32) functions -> . declare_fun declare_var LCURLY statutes RCURLY endfunc functions
    (33) functions -> . declare_fun LCURLY statutes RCURLY endfunc functions
    (28) declare_fun -> . FUNCTION return_type addtype ID addfun LPAREN RPAREN
    (29) declare_fun -> . FUNCTION return_type addtype ID addfun LPAREN paramstatus params paramstatus RPAREN

    MAIN            reduce using rule 30 (functions -> declare_fun declare_var LCURLY statutes RCURLY endfunc .)
    FUNCTION        shift and go to state 15

    declare_fun                    shift and go to state 14
    functions                      shift and go to state 193

state 148

    (33) functions -> declare_fun LCURLY statutes RCURLY endfunc functions .

    MAIN            reduce using rule 33 (functions -> declare_fun LCURLY statutes RCURLY endfunc functions .)


state 149

    (53) assign -> ID pushid EQUALS exprs . assignment SEMI
    (55) assignment -> .

    SEMI            reduce using rule 55 (assignment -> .)

    assignment                     shift and go to state 194

state 150

    (54) assign -> ID pushid LBRACK exprs . RBRACK verif EQUALS exprs assignment SEMI

    RBRACK          shift and go to state 195


state 151

    (56) call_void -> ID call exprp confirm . SEMI

    SEMI            shift and go to state 196


state 152

    (57) call_void -> ID call LPAREN RPAREN . confirm SEMI
    (137) confirm -> .

    SEMI            reduce using rule 137 (confirm -> .)

    confirm                        shift and go to state 197

state 153

    (58) call_void -> special2 exprp sconfirm2 SEMI .

    ID              reduce using rule 58 (call_void -> special2 exprp sconfirm2 SEMI .)
    RETURN          reduce using rule 58 (call_void -> special2 exprp sconfirm2 SEMI .)
    READ            reduce using rule 58 (call_void -> special2 exprp sconfirm2 SEMI .)
    WRITE           reduce using rule 58 (call_void -> special2 exprp sconfirm2 SEMI .)
    IF              reduce using rule 58 (call_void -> special2 exprp sconfirm2 SEMI .)
    WHILE           reduce using rule 58 (call_void -> special2 exprp sconfirm2 SEMI .)
    FOR             reduce using rule 58 (call_void -> special2 exprp sconfirm2 SEMI .)
    REGRESION       reduce using rule 58 (call_void -> special2 exprp sconfirm2 SEMI .)
    PLOT            reduce using rule 58 (call_void -> special2 exprp sconfirm2 SEMI .)
    RCURLY          reduce using rule 58 (call_void -> special2 exprp sconfirm2 SEMI .)


state 154

    (103) exprp -> LPAREN pushop exprs . RPAREN popop

    RPAREN          shift and go to state 198


state 155

    (62) returning -> RETURN LPAREN exprs returnquad . RPAREN SEMI

    RPAREN          shift and go to state 199


state 156

    (64) reading -> READ LPAREN read_opt RPAREN . SEMI

    SEMI            shift and go to state 200


state 157

    (65) read_opt -> expr readquad .
    (66) read_opt -> expr readquad . COMMA read_opt

    RPAREN          reduce using rule 65 (read_opt -> expr readquad .)
    COMMA           shift and go to state 201


state 158

    (68) writing -> WRITE LPAREN write_opt RPAREN . SEMI

    SEMI            shift and go to state 202


state 159

    (69) write_opt -> MESSAGE writequad1 .
    (70) write_opt -> MESSAGE writequad1 . COMMA write_opt

    RPAREN          reduce using rule 69 (write_opt -> MESSAGE writequad1 .)
    COMMA           shift and go to state 203


state 160

    (71) write_opt -> exprs writequad2 .
    (72) write_opt -> exprs writequad2 . COMMA write_opt

    RPAREN          reduce using rule 71 (write_opt -> exprs writequad2 .)
    COMMA           shift and go to state 204


state 161

    (75) decision -> IF LPAREN logic RPAREN . ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> IF LPAREN logic RPAREN . ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (77) ifquad -> .

    THEN            reduce using rule 77 (ifquad -> .)

    ifquad                         shift and go to state 205

state 162

    (84) logic -> relation AND . relation logicquad
    (87) relation -> . exprs GREATER exprs logicquad
    (88) relation -> . exprs GREATER_EQ exprs logicquad
    (89) relation -> . exprs LESSER exprs logicquad
    (90) relation -> . exprs LESSER_EQ exprs logicquad
    (91) relation -> . exprs COMPARE exprs logicquad
    (92) relation -> . exprs DIFFERENT exprs logicquad
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    relation                       shift and go to state 206
    exprs                          shift and go to state 119
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 163

    (85) logic -> relation OR . relation logicquad
    (87) relation -> . exprs GREATER exprs logicquad
    (88) relation -> . exprs GREATER_EQ exprs logicquad
    (89) relation -> . exprs LESSER exprs logicquad
    (90) relation -> . exprs LESSER_EQ exprs logicquad
    (91) relation -> . exprs COMPARE exprs logicquad
    (92) relation -> . exprs DIFFERENT exprs logicquad
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    relation                       shift and go to state 207
    exprs                          shift and go to state 119
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 164

    (87) relation -> exprs GREATER . exprs logicquad
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 208
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 165

    (88) relation -> exprs GREATER_EQ . exprs logicquad
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 209
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 166

    (89) relation -> exprs LESSER . exprs logicquad
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 210
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 167

    (90) relation -> exprs LESSER_EQ . exprs logicquad
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 211
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 168

    (91) relation -> exprs COMPARE . exprs logicquad
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 212
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 169

    (92) relation -> exprs DIFFERENT . exprs logicquad
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 213
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 170

    (80) conditional -> WHILE loopquad LPAREN logic . RPAREN whilequad DO LCURLY statutes RCURLY endquad

    RPAREN          shift and go to state 214


state 171

    (94) nonconditional -> FOR exprs forquad1 EQUALS . exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 215
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 172

    (100) exprs -> expr pams COMMA . exprs
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    expr                           shift and go to state 82
    exprs                          shift and go to state 216
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 173

    (105) expr -> expr PLUS pushop . term quad1
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    term                           shift and go to state 217
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 174

    (106) expr -> expr MINUS pushop . term quad1
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    term                           shift and go to state 218
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 175

    (102) exprs -> exprp pams COMMA . exprs
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprp                          shift and go to state 83
    exprs                          shift and go to state 219
    expr                           shift and go to state 82
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 176

    (108) term -> term TIMES pushop . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    factor                         shift and go to state 220
    special1                       shift and go to state 91

state 177

    (109) term -> term DIVIDE pushop . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    factor                         shift and go to state 221
    special1                       shift and go to state 91

state 178

    (115) factor -> MINUS C_INT pushintn .

    TIMES           reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    DIVIDE          reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    PLUS            reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    MINUS           reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    COMMA           reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    EQUALS          reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    RPAREN          reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    GREATER         reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    GREATER_EQ      reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    LESSER          reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    LESSER_EQ       reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    COMPARE         reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    DIFFERENT       reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    SEMI            reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    RBRACK          reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    AND             reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    OR              reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    TO              reduce using rule 115 (factor -> MINUS C_INT pushintn .)
    DO              reduce using rule 115 (factor -> MINUS C_INT pushintn .)


state 179

    (117) factor -> MINUS C_FLOAT pushfloatn .

    TIMES           reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    DIVIDE          reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    PLUS            reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    MINUS           reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    COMMA           reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    EQUALS          reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    RPAREN          reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    GREATER         reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    GREATER_EQ      reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    LESSER          reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    LESSER_EQ       reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    COMPARE         reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    DIFFERENT       reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    SEMI            reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    RBRACK          reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    AND             reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    OR              reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    TO              reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)
    DO              reduce using rule 117 (factor -> MINUS C_FLOAT pushfloatn .)


state 180

    (120) factor -> ID pushid LBRACK . expr RBRACK verif
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    expr                           shift and go to state 222
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 181

    (121) factor -> ID call LPAREN . RPAREN confirm
    (103) exprp -> LPAREN . pushop exprs RPAREN popop
    (113) pushop -> .

    RPAREN          shift and go to state 223
    LPAREN          reduce using rule 113 (pushop -> .)
    C_INT           reduce using rule 113 (pushop -> .)
    MINUS           reduce using rule 113 (pushop -> .)
    C_FLOAT         reduce using rule 113 (pushop -> .)
    C_CHAR          reduce using rule 113 (pushop -> .)
    ID              reduce using rule 113 (pushop -> .)
    MEDIA           reduce using rule 113 (pushop -> .)
    MODA            reduce using rule 113 (pushop -> .)
    VARIANZA        reduce using rule 113 (pushop -> .)

    pushop                         shift and go to state 110

state 182

    (122) factor -> ID call exprp . confirm
    (137) confirm -> .

    TIMES           reduce using rule 137 (confirm -> .)
    DIVIDE          reduce using rule 137 (confirm -> .)
    PLUS            reduce using rule 137 (confirm -> .)
    MINUS           reduce using rule 137 (confirm -> .)
    COMMA           reduce using rule 137 (confirm -> .)
    EQUALS          reduce using rule 137 (confirm -> .)
    RPAREN          reduce using rule 137 (confirm -> .)
    GREATER         reduce using rule 137 (confirm -> .)
    GREATER_EQ      reduce using rule 137 (confirm -> .)
    LESSER          reduce using rule 137 (confirm -> .)
    LESSER_EQ       reduce using rule 137 (confirm -> .)
    COMPARE         reduce using rule 137 (confirm -> .)
    DIFFERENT       reduce using rule 137 (confirm -> .)
    SEMI            reduce using rule 137 (confirm -> .)
    RBRACK          reduce using rule 137 (confirm -> .)
    AND             reduce using rule 137 (confirm -> .)
    OR              reduce using rule 137 (confirm -> .)
    TO              reduce using rule 137 (confirm -> .)
    DO              reduce using rule 137 (confirm -> .)

    confirm                        shift and go to state 224

state 183

    (123) factor -> special1 exprp sconfirm1 .

    TIMES           reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    DIVIDE          reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    PLUS            reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    MINUS           reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    COMMA           reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    EQUALS          reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    RPAREN          reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    GREATER         reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    GREATER_EQ      reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    LESSER          reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    LESSER_EQ       reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    COMPARE         reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    DIFFERENT       reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    SEMI            reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    RBRACK          reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    AND             reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    OR              reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    TO              reduce using rule 123 (factor -> special1 exprp sconfirm1 .)
    DO              reduce using rule 123 (factor -> special1 exprp sconfirm1 .)


state 184

    (28) declare_fun -> FUNCTION return_type addtype ID addfun LPAREN . RPAREN
    (29) declare_fun -> FUNCTION return_type addtype ID addfun LPAREN . paramstatus params paramstatus RPAREN
    (35) paramstatus -> .

    RPAREN          shift and go to state 225
    INT             reduce using rule 35 (paramstatus -> .)
    FLOAT           reduce using rule 35 (paramstatus -> .)
    CHAR            reduce using rule 35 (paramstatus -> .)

    paramstatus                    shift and go to state 226

state 185

    (4) program_structure -> PROGRAM initiate ID addfun addprog SEMI MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY . endfunc
    (34) endfunc -> .

    $end            reduce using rule 34 (endfunc -> .)

    endfunc                        shift and go to state 227

state 186

    (15) multitypes -> type addtype COLON multivars SEMI multitypes .

    MAIN            reduce using rule 15 (multitypes -> type addtype COLON multivars SEMI multitypes .)
    FUNCTION        reduce using rule 15 (multitypes -> type addtype COLON multivars SEMI multitypes .)
    LCURLY          reduce using rule 15 (multitypes -> type addtype COLON multivars SEMI multitypes .)


state 187

    (18) multivars -> ID addvar COMMA . multivars
    (17) multivars -> . ID addvar
    (18) multivars -> . ID addvar COMMA multivars
    (19) multivars -> . dimvars addvard
    (20) multivars -> . dimvars addvard COMMA multivars
    (21) dimvars -> . ID LBRACK expr RBRACK

    ID              shift and go to state 98

    multivars                      shift and go to state 228
    dimvars                        shift and go to state 99

state 188

    (21) dimvars -> ID LBRACK expr . RBRACK
    (105) expr -> expr . PLUS pushop term quad1
    (106) expr -> expr . MINUS pushop term quad1

    RBRACK          shift and go to state 229
    PLUS            shift and go to state 123
    MINUS           shift and go to state 124


state 189

    (20) multivars -> dimvars addvard COMMA . multivars
    (17) multivars -> . ID addvar
    (18) multivars -> . ID addvar COMMA multivars
    (19) multivars -> . dimvars addvard
    (20) multivars -> . dimvars addvard COMMA multivars
    (21) dimvars -> . ID LBRACK expr RBRACK

    ID              shift and go to state 98

    dimvars                        shift and go to state 99
    multivars                      shift and go to state 230

state 190

    (1) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope functions MAIN changeback LPAREN RPAREN LCURLY . statutes RCURLY endfunc
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    statutes                       shift and go to state 231
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 191

    (2) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope MAIN changeback LPAREN RPAREN LCURLY statutes . RCURLY endfunc

    RCURLY          shift and go to state 232


state 192

    (3) program_structure -> PROGRAM initiate ID addfun addprog SEMI changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes . RCURLY endfunc

    RCURLY          shift and go to state 233


state 193

    (32) functions -> declare_fun declare_var LCURLY statutes RCURLY endfunc functions .

    MAIN            reduce using rule 32 (functions -> declare_fun declare_var LCURLY statutes RCURLY endfunc functions .)


state 194

    (53) assign -> ID pushid EQUALS exprs assignment . SEMI

    SEMI            shift and go to state 234


state 195

    (54) assign -> ID pushid LBRACK exprs RBRACK . verif EQUALS exprs assignment SEMI
    (134) verif -> .

    EQUALS          reduce using rule 134 (verif -> .)

    verif                          shift and go to state 235

state 196

    (56) call_void -> ID call exprp confirm SEMI .

    ID              reduce using rule 56 (call_void -> ID call exprp confirm SEMI .)
    RETURN          reduce using rule 56 (call_void -> ID call exprp confirm SEMI .)
    READ            reduce using rule 56 (call_void -> ID call exprp confirm SEMI .)
    WRITE           reduce using rule 56 (call_void -> ID call exprp confirm SEMI .)
    IF              reduce using rule 56 (call_void -> ID call exprp confirm SEMI .)
    WHILE           reduce using rule 56 (call_void -> ID call exprp confirm SEMI .)
    FOR             reduce using rule 56 (call_void -> ID call exprp confirm SEMI .)
    REGRESION       reduce using rule 56 (call_void -> ID call exprp confirm SEMI .)
    PLOT            reduce using rule 56 (call_void -> ID call exprp confirm SEMI .)
    RCURLY          reduce using rule 56 (call_void -> ID call exprp confirm SEMI .)


state 197

    (57) call_void -> ID call LPAREN RPAREN confirm . SEMI

    SEMI            shift and go to state 236


state 198

    (103) exprp -> LPAREN pushop exprs RPAREN . popop
    (104) popop -> .

    SEMI            reduce using rule 104 (popop -> .)
    COMMA           reduce using rule 104 (popop -> .)
    EQUALS          reduce using rule 104 (popop -> .)
    RPAREN          reduce using rule 104 (popop -> .)
    GREATER         reduce using rule 104 (popop -> .)
    GREATER_EQ      reduce using rule 104 (popop -> .)
    LESSER          reduce using rule 104 (popop -> .)
    LESSER_EQ       reduce using rule 104 (popop -> .)
    COMPARE         reduce using rule 104 (popop -> .)
    DIFFERENT       reduce using rule 104 (popop -> .)
    TIMES           reduce using rule 104 (popop -> .)
    DIVIDE          reduce using rule 104 (popop -> .)
    PLUS            reduce using rule 104 (popop -> .)
    MINUS           reduce using rule 104 (popop -> .)
    RBRACK          reduce using rule 104 (popop -> .)
    AND             reduce using rule 104 (popop -> .)
    OR              reduce using rule 104 (popop -> .)
    TO              reduce using rule 104 (popop -> .)
    DO              reduce using rule 104 (popop -> .)

    popop                          shift and go to state 237

state 199

    (62) returning -> RETURN LPAREN exprs returnquad RPAREN . SEMI

    SEMI            shift and go to state 238


state 200

    (64) reading -> READ LPAREN read_opt RPAREN SEMI .

    ID              reduce using rule 64 (reading -> READ LPAREN read_opt RPAREN SEMI .)
    RETURN          reduce using rule 64 (reading -> READ LPAREN read_opt RPAREN SEMI .)
    READ            reduce using rule 64 (reading -> READ LPAREN read_opt RPAREN SEMI .)
    WRITE           reduce using rule 64 (reading -> READ LPAREN read_opt RPAREN SEMI .)
    IF              reduce using rule 64 (reading -> READ LPAREN read_opt RPAREN SEMI .)
    WHILE           reduce using rule 64 (reading -> READ LPAREN read_opt RPAREN SEMI .)
    FOR             reduce using rule 64 (reading -> READ LPAREN read_opt RPAREN SEMI .)
    REGRESION       reduce using rule 64 (reading -> READ LPAREN read_opt RPAREN SEMI .)
    PLOT            reduce using rule 64 (reading -> READ LPAREN read_opt RPAREN SEMI .)
    RCURLY          reduce using rule 64 (reading -> READ LPAREN read_opt RPAREN SEMI .)


state 201

    (66) read_opt -> expr readquad COMMA . read_opt
    (65) read_opt -> . expr readquad
    (66) read_opt -> . expr readquad COMMA read_opt
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    expr                           shift and go to state 113
    read_opt                       shift and go to state 239
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 202

    (68) writing -> WRITE LPAREN write_opt RPAREN SEMI .

    ID              reduce using rule 68 (writing -> WRITE LPAREN write_opt RPAREN SEMI .)
    RETURN          reduce using rule 68 (writing -> WRITE LPAREN write_opt RPAREN SEMI .)
    READ            reduce using rule 68 (writing -> WRITE LPAREN write_opt RPAREN SEMI .)
    WRITE           reduce using rule 68 (writing -> WRITE LPAREN write_opt RPAREN SEMI .)
    IF              reduce using rule 68 (writing -> WRITE LPAREN write_opt RPAREN SEMI .)
    WHILE           reduce using rule 68 (writing -> WRITE LPAREN write_opt RPAREN SEMI .)
    FOR             reduce using rule 68 (writing -> WRITE LPAREN write_opt RPAREN SEMI .)
    REGRESION       reduce using rule 68 (writing -> WRITE LPAREN write_opt RPAREN SEMI .)
    PLOT            reduce using rule 68 (writing -> WRITE LPAREN write_opt RPAREN SEMI .)
    RCURLY          reduce using rule 68 (writing -> WRITE LPAREN write_opt RPAREN SEMI .)


state 203

    (70) write_opt -> MESSAGE writequad1 COMMA . write_opt
    (69) write_opt -> . MESSAGE writequad1
    (70) write_opt -> . MESSAGE writequad1 COMMA write_opt
    (71) write_opt -> . exprs writequad2
    (72) write_opt -> . exprs writequad2 COMMA write_opt
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    MESSAGE         shift and go to state 115
    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    write_opt                      shift and go to state 240
    exprs                          shift and go to state 116
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 204

    (72) write_opt -> exprs writequad2 COMMA . write_opt
    (69) write_opt -> . MESSAGE writequad1
    (70) write_opt -> . MESSAGE writequad1 COMMA write_opt
    (71) write_opt -> . exprs writequad2
    (72) write_opt -> . exprs writequad2 COMMA write_opt
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    MESSAGE         shift and go to state 115
    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 116
    write_opt                      shift and go to state 241
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 205

    (75) decision -> IF LPAREN logic RPAREN ifquad . THEN LCURLY statutes RCURLY filljump
    (76) decision -> IF LPAREN logic RPAREN ifquad . THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump

    THEN            shift and go to state 242


state 206

    (84) logic -> relation AND relation . logicquad
    (93) logicquad -> .

    RPAREN          reduce using rule 93 (logicquad -> .)

    logicquad                      shift and go to state 243

state 207

    (85) logic -> relation OR relation . logicquad
    (93) logicquad -> .

    RPAREN          reduce using rule 93 (logicquad -> .)

    logicquad                      shift and go to state 244

state 208

    (87) relation -> exprs GREATER exprs . logicquad
    (93) logicquad -> .

    AND             reduce using rule 93 (logicquad -> .)
    OR              reduce using rule 93 (logicquad -> .)
    RPAREN          reduce using rule 93 (logicquad -> .)

    logicquad                      shift and go to state 245

state 209

    (88) relation -> exprs GREATER_EQ exprs . logicquad
    (93) logicquad -> .

    AND             reduce using rule 93 (logicquad -> .)
    OR              reduce using rule 93 (logicquad -> .)
    RPAREN          reduce using rule 93 (logicquad -> .)

    logicquad                      shift and go to state 246

state 210

    (89) relation -> exprs LESSER exprs . logicquad
    (93) logicquad -> .

    AND             reduce using rule 93 (logicquad -> .)
    OR              reduce using rule 93 (logicquad -> .)
    RPAREN          reduce using rule 93 (logicquad -> .)

    logicquad                      shift and go to state 247

state 211

    (90) relation -> exprs LESSER_EQ exprs . logicquad
    (93) logicquad -> .

    AND             reduce using rule 93 (logicquad -> .)
    OR              reduce using rule 93 (logicquad -> .)
    RPAREN          reduce using rule 93 (logicquad -> .)

    logicquad                      shift and go to state 248

state 212

    (91) relation -> exprs COMPARE exprs . logicquad
    (93) logicquad -> .

    AND             reduce using rule 93 (logicquad -> .)
    OR              reduce using rule 93 (logicquad -> .)
    RPAREN          reduce using rule 93 (logicquad -> .)

    logicquad                      shift and go to state 249

state 213

    (92) relation -> exprs DIFFERENT exprs . logicquad
    (93) logicquad -> .

    AND             reduce using rule 93 (logicquad -> .)
    OR              reduce using rule 93 (logicquad -> .)
    RPAREN          reduce using rule 93 (logicquad -> .)

    logicquad                      shift and go to state 250

state 214

    (80) conditional -> WHILE loopquad LPAREN logic RPAREN . whilequad DO LCURLY statutes RCURLY endquad
    (82) whilequad -> .

    DO              reduce using rule 82 (whilequad -> .)

    whilequad                      shift and go to state 251

state 215

    (94) nonconditional -> FOR exprs forquad1 EQUALS exprs . forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (96) forquad2 -> .

    TO              reduce using rule 96 (forquad2 -> .)

    forquad2                       shift and go to state 252

state 216

    (100) exprs -> expr pams COMMA exprs .

    EQUALS          reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    RPAREN          reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    COMMA           reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    GREATER         reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    GREATER_EQ      reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    LESSER          reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    LESSER_EQ       reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    COMPARE         reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    DIFFERENT       reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    SEMI            reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    RBRACK          reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    AND             reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    OR              reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    TO              reduce using rule 100 (exprs -> expr pams COMMA exprs .)
    DO              reduce using rule 100 (exprs -> expr pams COMMA exprs .)


state 217

    (105) expr -> expr PLUS pushop term . quad1
    (108) term -> term . TIMES pushop factor quad2
    (109) term -> term . DIVIDE pushop factor quad2
    (111) quad1 -> .

    TIMES           shift and go to state 127
    DIVIDE          shift and go to state 128
    PLUS            reduce using rule 111 (quad1 -> .)
    MINUS           reduce using rule 111 (quad1 -> .)
    COMMA           reduce using rule 111 (quad1 -> .)
    EQUALS          reduce using rule 111 (quad1 -> .)
    RPAREN          reduce using rule 111 (quad1 -> .)
    GREATER         reduce using rule 111 (quad1 -> .)
    GREATER_EQ      reduce using rule 111 (quad1 -> .)
    LESSER          reduce using rule 111 (quad1 -> .)
    LESSER_EQ       reduce using rule 111 (quad1 -> .)
    COMPARE         reduce using rule 111 (quad1 -> .)
    DIFFERENT       reduce using rule 111 (quad1 -> .)
    SEMI            reduce using rule 111 (quad1 -> .)
    RBRACK          reduce using rule 111 (quad1 -> .)
    AND             reduce using rule 111 (quad1 -> .)
    OR              reduce using rule 111 (quad1 -> .)
    TO              reduce using rule 111 (quad1 -> .)
    DO              reduce using rule 111 (quad1 -> .)

    quad1                          shift and go to state 253

state 218

    (106) expr -> expr MINUS pushop term . quad1
    (108) term -> term . TIMES pushop factor quad2
    (109) term -> term . DIVIDE pushop factor quad2
    (111) quad1 -> .

    TIMES           shift and go to state 127
    DIVIDE          shift and go to state 128
    PLUS            reduce using rule 111 (quad1 -> .)
    MINUS           reduce using rule 111 (quad1 -> .)
    COMMA           reduce using rule 111 (quad1 -> .)
    EQUALS          reduce using rule 111 (quad1 -> .)
    RPAREN          reduce using rule 111 (quad1 -> .)
    GREATER         reduce using rule 111 (quad1 -> .)
    GREATER_EQ      reduce using rule 111 (quad1 -> .)
    LESSER          reduce using rule 111 (quad1 -> .)
    LESSER_EQ       reduce using rule 111 (quad1 -> .)
    COMPARE         reduce using rule 111 (quad1 -> .)
    DIFFERENT       reduce using rule 111 (quad1 -> .)
    SEMI            reduce using rule 111 (quad1 -> .)
    RBRACK          reduce using rule 111 (quad1 -> .)
    AND             reduce using rule 111 (quad1 -> .)
    OR              reduce using rule 111 (quad1 -> .)
    TO              reduce using rule 111 (quad1 -> .)
    DO              reduce using rule 111 (quad1 -> .)

    quad1                          shift and go to state 254

state 219

    (102) exprs -> exprp pams COMMA exprs .

    EQUALS          reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    RPAREN          reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    COMMA           reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    GREATER         reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    GREATER_EQ      reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    LESSER          reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    LESSER_EQ       reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    COMPARE         reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    DIFFERENT       reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    SEMI            reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    RBRACK          reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    AND             reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    OR              reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    TO              reduce using rule 102 (exprs -> exprp pams COMMA exprs .)
    DO              reduce using rule 102 (exprs -> exprp pams COMMA exprs .)


state 220

    (108) term -> term TIMES pushop factor . quad2
    (112) quad2 -> .

    TIMES           reduce using rule 112 (quad2 -> .)
    DIVIDE          reduce using rule 112 (quad2 -> .)
    PLUS            reduce using rule 112 (quad2 -> .)
    MINUS           reduce using rule 112 (quad2 -> .)
    COMMA           reduce using rule 112 (quad2 -> .)
    EQUALS          reduce using rule 112 (quad2 -> .)
    RPAREN          reduce using rule 112 (quad2 -> .)
    GREATER         reduce using rule 112 (quad2 -> .)
    GREATER_EQ      reduce using rule 112 (quad2 -> .)
    LESSER          reduce using rule 112 (quad2 -> .)
    LESSER_EQ       reduce using rule 112 (quad2 -> .)
    COMPARE         reduce using rule 112 (quad2 -> .)
    DIFFERENT       reduce using rule 112 (quad2 -> .)
    SEMI            reduce using rule 112 (quad2 -> .)
    RBRACK          reduce using rule 112 (quad2 -> .)
    AND             reduce using rule 112 (quad2 -> .)
    OR              reduce using rule 112 (quad2 -> .)
    TO              reduce using rule 112 (quad2 -> .)
    DO              reduce using rule 112 (quad2 -> .)

    quad2                          shift and go to state 255

state 221

    (109) term -> term DIVIDE pushop factor . quad2
    (112) quad2 -> .

    TIMES           reduce using rule 112 (quad2 -> .)
    DIVIDE          reduce using rule 112 (quad2 -> .)
    PLUS            reduce using rule 112 (quad2 -> .)
    MINUS           reduce using rule 112 (quad2 -> .)
    COMMA           reduce using rule 112 (quad2 -> .)
    EQUALS          reduce using rule 112 (quad2 -> .)
    RPAREN          reduce using rule 112 (quad2 -> .)
    GREATER         reduce using rule 112 (quad2 -> .)
    GREATER_EQ      reduce using rule 112 (quad2 -> .)
    LESSER          reduce using rule 112 (quad2 -> .)
    LESSER_EQ       reduce using rule 112 (quad2 -> .)
    COMPARE         reduce using rule 112 (quad2 -> .)
    DIFFERENT       reduce using rule 112 (quad2 -> .)
    SEMI            reduce using rule 112 (quad2 -> .)
    RBRACK          reduce using rule 112 (quad2 -> .)
    AND             reduce using rule 112 (quad2 -> .)
    OR              reduce using rule 112 (quad2 -> .)
    TO              reduce using rule 112 (quad2 -> .)
    DO              reduce using rule 112 (quad2 -> .)

    quad2                          shift and go to state 256

state 222

    (120) factor -> ID pushid LBRACK expr . RBRACK verif
    (105) expr -> expr . PLUS pushop term quad1
    (106) expr -> expr . MINUS pushop term quad1

    RBRACK          shift and go to state 257
    PLUS            shift and go to state 123
    MINUS           shift and go to state 124


state 223

    (121) factor -> ID call LPAREN RPAREN . confirm
    (137) confirm -> .

    TIMES           reduce using rule 137 (confirm -> .)
    DIVIDE          reduce using rule 137 (confirm -> .)
    PLUS            reduce using rule 137 (confirm -> .)
    MINUS           reduce using rule 137 (confirm -> .)
    COMMA           reduce using rule 137 (confirm -> .)
    EQUALS          reduce using rule 137 (confirm -> .)
    RPAREN          reduce using rule 137 (confirm -> .)
    GREATER         reduce using rule 137 (confirm -> .)
    GREATER_EQ      reduce using rule 137 (confirm -> .)
    LESSER          reduce using rule 137 (confirm -> .)
    LESSER_EQ       reduce using rule 137 (confirm -> .)
    COMPARE         reduce using rule 137 (confirm -> .)
    DIFFERENT       reduce using rule 137 (confirm -> .)
    SEMI            reduce using rule 137 (confirm -> .)
    RBRACK          reduce using rule 137 (confirm -> .)
    AND             reduce using rule 137 (confirm -> .)
    OR              reduce using rule 137 (confirm -> .)
    TO              reduce using rule 137 (confirm -> .)
    DO              reduce using rule 137 (confirm -> .)

    confirm                        shift and go to state 258

state 224

    (122) factor -> ID call exprp confirm .

    TIMES           reduce using rule 122 (factor -> ID call exprp confirm .)
    DIVIDE          reduce using rule 122 (factor -> ID call exprp confirm .)
    PLUS            reduce using rule 122 (factor -> ID call exprp confirm .)
    MINUS           reduce using rule 122 (factor -> ID call exprp confirm .)
    COMMA           reduce using rule 122 (factor -> ID call exprp confirm .)
    EQUALS          reduce using rule 122 (factor -> ID call exprp confirm .)
    RPAREN          reduce using rule 122 (factor -> ID call exprp confirm .)
    GREATER         reduce using rule 122 (factor -> ID call exprp confirm .)
    GREATER_EQ      reduce using rule 122 (factor -> ID call exprp confirm .)
    LESSER          reduce using rule 122 (factor -> ID call exprp confirm .)
    LESSER_EQ       reduce using rule 122 (factor -> ID call exprp confirm .)
    COMPARE         reduce using rule 122 (factor -> ID call exprp confirm .)
    DIFFERENT       reduce using rule 122 (factor -> ID call exprp confirm .)
    SEMI            reduce using rule 122 (factor -> ID call exprp confirm .)
    RBRACK          reduce using rule 122 (factor -> ID call exprp confirm .)
    AND             reduce using rule 122 (factor -> ID call exprp confirm .)
    OR              reduce using rule 122 (factor -> ID call exprp confirm .)
    TO              reduce using rule 122 (factor -> ID call exprp confirm .)
    DO              reduce using rule 122 (factor -> ID call exprp confirm .)


state 225

    (28) declare_fun -> FUNCTION return_type addtype ID addfun LPAREN RPAREN .

    LCURLY          reduce using rule 28 (declare_fun -> FUNCTION return_type addtype ID addfun LPAREN RPAREN .)
    VARS            reduce using rule 28 (declare_fun -> FUNCTION return_type addtype ID addfun LPAREN RPAREN .)


state 226

    (29) declare_fun -> FUNCTION return_type addtype ID addfun LPAREN paramstatus . params paramstatus RPAREN
    (36) params -> . type addtype COLON multivars
    (37) params -> . type addtype COLON multivars SEMI params
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . CHAR

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    params                         shift and go to state 259
    type                           shift and go to state 260

state 227

    (4) program_structure -> PROGRAM initiate ID addfun addprog SEMI MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc .

    $end            reduce using rule 4 (program_structure -> PROGRAM initiate ID addfun addprog SEMI MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc .)


state 228

    (18) multivars -> ID addvar COMMA multivars .

    SEMI            reduce using rule 18 (multivars -> ID addvar COMMA multivars .)
    RPAREN          reduce using rule 18 (multivars -> ID addvar COMMA multivars .)


state 229

    (21) dimvars -> ID LBRACK expr RBRACK .

    COMMA           reduce using rule 21 (dimvars -> ID LBRACK expr RBRACK .)
    SEMI            reduce using rule 21 (dimvars -> ID LBRACK expr RBRACK .)
    RPAREN          reduce using rule 21 (dimvars -> ID LBRACK expr RBRACK .)


state 230

    (20) multivars -> dimvars addvard COMMA multivars .

    SEMI            reduce using rule 20 (multivars -> dimvars addvard COMMA multivars .)
    RPAREN          reduce using rule 20 (multivars -> dimvars addvard COMMA multivars .)


state 231

    (1) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes . RCURLY endfunc

    RCURLY          shift and go to state 261


state 232

    (2) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY . endfunc
    (34) endfunc -> .

    $end            reduce using rule 34 (endfunc -> .)

    endfunc                        shift and go to state 262

state 233

    (3) program_structure -> PROGRAM initiate ID addfun addprog SEMI changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY . endfunc
    (34) endfunc -> .

    $end            reduce using rule 34 (endfunc -> .)

    endfunc                        shift and go to state 263

state 234

    (53) assign -> ID pushid EQUALS exprs assignment SEMI .

    ID              reduce using rule 53 (assign -> ID pushid EQUALS exprs assignment SEMI .)
    RETURN          reduce using rule 53 (assign -> ID pushid EQUALS exprs assignment SEMI .)
    READ            reduce using rule 53 (assign -> ID pushid EQUALS exprs assignment SEMI .)
    WRITE           reduce using rule 53 (assign -> ID pushid EQUALS exprs assignment SEMI .)
    IF              reduce using rule 53 (assign -> ID pushid EQUALS exprs assignment SEMI .)
    WHILE           reduce using rule 53 (assign -> ID pushid EQUALS exprs assignment SEMI .)
    FOR             reduce using rule 53 (assign -> ID pushid EQUALS exprs assignment SEMI .)
    REGRESION       reduce using rule 53 (assign -> ID pushid EQUALS exprs assignment SEMI .)
    PLOT            reduce using rule 53 (assign -> ID pushid EQUALS exprs assignment SEMI .)
    RCURLY          reduce using rule 53 (assign -> ID pushid EQUALS exprs assignment SEMI .)


state 235

    (54) assign -> ID pushid LBRACK exprs RBRACK verif . EQUALS exprs assignment SEMI

    EQUALS          shift and go to state 264


state 236

    (57) call_void -> ID call LPAREN RPAREN confirm SEMI .

    ID              reduce using rule 57 (call_void -> ID call LPAREN RPAREN confirm SEMI .)
    RETURN          reduce using rule 57 (call_void -> ID call LPAREN RPAREN confirm SEMI .)
    READ            reduce using rule 57 (call_void -> ID call LPAREN RPAREN confirm SEMI .)
    WRITE           reduce using rule 57 (call_void -> ID call LPAREN RPAREN confirm SEMI .)
    IF              reduce using rule 57 (call_void -> ID call LPAREN RPAREN confirm SEMI .)
    WHILE           reduce using rule 57 (call_void -> ID call LPAREN RPAREN confirm SEMI .)
    FOR             reduce using rule 57 (call_void -> ID call LPAREN RPAREN confirm SEMI .)
    REGRESION       reduce using rule 57 (call_void -> ID call LPAREN RPAREN confirm SEMI .)
    PLOT            reduce using rule 57 (call_void -> ID call LPAREN RPAREN confirm SEMI .)
    RCURLY          reduce using rule 57 (call_void -> ID call LPAREN RPAREN confirm SEMI .)


state 237

    (103) exprp -> LPAREN pushop exprs RPAREN popop .

    SEMI            reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    COMMA           reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    EQUALS          reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    RPAREN          reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    GREATER         reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    GREATER_EQ      reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    LESSER          reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    LESSER_EQ       reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    COMPARE         reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    DIFFERENT       reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    TIMES           reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    DIVIDE          reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    PLUS            reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    MINUS           reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    RBRACK          reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    AND             reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    OR              reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    TO              reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)
    DO              reduce using rule 103 (exprp -> LPAREN pushop exprs RPAREN popop .)


state 238

    (62) returning -> RETURN LPAREN exprs returnquad RPAREN SEMI .

    RCURLY          reduce using rule 62 (returning -> RETURN LPAREN exprs returnquad RPAREN SEMI .)


state 239

    (66) read_opt -> expr readquad COMMA read_opt .

    RPAREN          reduce using rule 66 (read_opt -> expr readquad COMMA read_opt .)


state 240

    (70) write_opt -> MESSAGE writequad1 COMMA write_opt .

    RPAREN          reduce using rule 70 (write_opt -> MESSAGE writequad1 COMMA write_opt .)


state 241

    (72) write_opt -> exprs writequad2 COMMA write_opt .

    RPAREN          reduce using rule 72 (write_opt -> exprs writequad2 COMMA write_opt .)


state 242

    (75) decision -> IF LPAREN logic RPAREN ifquad THEN . LCURLY statutes RCURLY filljump
    (76) decision -> IF LPAREN logic RPAREN ifquad THEN . LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump

    LCURLY          shift and go to state 265


state 243

    (84) logic -> relation AND relation logicquad .

    RPAREN          reduce using rule 84 (logic -> relation AND relation logicquad .)


state 244

    (85) logic -> relation OR relation logicquad .

    RPAREN          reduce using rule 85 (logic -> relation OR relation logicquad .)


state 245

    (87) relation -> exprs GREATER exprs logicquad .

    AND             reduce using rule 87 (relation -> exprs GREATER exprs logicquad .)
    OR              reduce using rule 87 (relation -> exprs GREATER exprs logicquad .)
    RPAREN          reduce using rule 87 (relation -> exprs GREATER exprs logicquad .)


state 246

    (88) relation -> exprs GREATER_EQ exprs logicquad .

    AND             reduce using rule 88 (relation -> exprs GREATER_EQ exprs logicquad .)
    OR              reduce using rule 88 (relation -> exprs GREATER_EQ exprs logicquad .)
    RPAREN          reduce using rule 88 (relation -> exprs GREATER_EQ exprs logicquad .)


state 247

    (89) relation -> exprs LESSER exprs logicquad .

    AND             reduce using rule 89 (relation -> exprs LESSER exprs logicquad .)
    OR              reduce using rule 89 (relation -> exprs LESSER exprs logicquad .)
    RPAREN          reduce using rule 89 (relation -> exprs LESSER exprs logicquad .)


state 248

    (90) relation -> exprs LESSER_EQ exprs logicquad .

    AND             reduce using rule 90 (relation -> exprs LESSER_EQ exprs logicquad .)
    OR              reduce using rule 90 (relation -> exprs LESSER_EQ exprs logicquad .)
    RPAREN          reduce using rule 90 (relation -> exprs LESSER_EQ exprs logicquad .)


state 249

    (91) relation -> exprs COMPARE exprs logicquad .

    AND             reduce using rule 91 (relation -> exprs COMPARE exprs logicquad .)
    OR              reduce using rule 91 (relation -> exprs COMPARE exprs logicquad .)
    RPAREN          reduce using rule 91 (relation -> exprs COMPARE exprs logicquad .)


state 250

    (92) relation -> exprs DIFFERENT exprs logicquad .

    AND             reduce using rule 92 (relation -> exprs DIFFERENT exprs logicquad .)
    OR              reduce using rule 92 (relation -> exprs DIFFERENT exprs logicquad .)
    RPAREN          reduce using rule 92 (relation -> exprs DIFFERENT exprs logicquad .)


state 251

    (80) conditional -> WHILE loopquad LPAREN logic RPAREN whilequad . DO LCURLY statutes RCURLY endquad

    DO              shift and go to state 266


state 252

    (94) nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 . TO exprs forquad3 DO LCURLY statutes RCURLY forquad4

    TO              shift and go to state 267


state 253

    (105) expr -> expr PLUS pushop term quad1 .

    PLUS            reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    MINUS           reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    COMMA           reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    EQUALS          reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    RPAREN          reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    GREATER         reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    GREATER_EQ      reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    LESSER          reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    LESSER_EQ       reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    COMPARE         reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    DIFFERENT       reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    SEMI            reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    RBRACK          reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    AND             reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    OR              reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    TO              reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)
    DO              reduce using rule 105 (expr -> expr PLUS pushop term quad1 .)


state 254

    (106) expr -> expr MINUS pushop term quad1 .

    PLUS            reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    MINUS           reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    COMMA           reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    EQUALS          reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    RPAREN          reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    GREATER         reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    GREATER_EQ      reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    LESSER          reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    LESSER_EQ       reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    COMPARE         reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    DIFFERENT       reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    SEMI            reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    RBRACK          reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    AND             reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    OR              reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    TO              reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)
    DO              reduce using rule 106 (expr -> expr MINUS pushop term quad1 .)


state 255

    (108) term -> term TIMES pushop factor quad2 .

    TIMES           reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    DIVIDE          reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    PLUS            reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    MINUS           reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    COMMA           reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    EQUALS          reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    RPAREN          reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    GREATER         reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    GREATER_EQ      reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    LESSER          reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    LESSER_EQ       reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    COMPARE         reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    DIFFERENT       reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    SEMI            reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    RBRACK          reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    AND             reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    OR              reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    TO              reduce using rule 108 (term -> term TIMES pushop factor quad2 .)
    DO              reduce using rule 108 (term -> term TIMES pushop factor quad2 .)


state 256

    (109) term -> term DIVIDE pushop factor quad2 .

    TIMES           reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    DIVIDE          reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    PLUS            reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    MINUS           reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    COMMA           reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    EQUALS          reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    RPAREN          reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    GREATER         reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    GREATER_EQ      reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    LESSER          reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    LESSER_EQ       reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    COMPARE         reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    DIFFERENT       reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    SEMI            reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    RBRACK          reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    AND             reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    OR              reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    TO              reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)
    DO              reduce using rule 109 (term -> term DIVIDE pushop factor quad2 .)


state 257

    (120) factor -> ID pushid LBRACK expr RBRACK . verif
    (134) verif -> .

    TIMES           reduce using rule 134 (verif -> .)
    DIVIDE          reduce using rule 134 (verif -> .)
    PLUS            reduce using rule 134 (verif -> .)
    MINUS           reduce using rule 134 (verif -> .)
    COMMA           reduce using rule 134 (verif -> .)
    EQUALS          reduce using rule 134 (verif -> .)
    RPAREN          reduce using rule 134 (verif -> .)
    GREATER         reduce using rule 134 (verif -> .)
    GREATER_EQ      reduce using rule 134 (verif -> .)
    LESSER          reduce using rule 134 (verif -> .)
    LESSER_EQ       reduce using rule 134 (verif -> .)
    COMPARE         reduce using rule 134 (verif -> .)
    DIFFERENT       reduce using rule 134 (verif -> .)
    SEMI            reduce using rule 134 (verif -> .)
    RBRACK          reduce using rule 134 (verif -> .)
    AND             reduce using rule 134 (verif -> .)
    OR              reduce using rule 134 (verif -> .)
    TO              reduce using rule 134 (verif -> .)
    DO              reduce using rule 134 (verif -> .)

    verif                          shift and go to state 268

state 258

    (121) factor -> ID call LPAREN RPAREN confirm .

    TIMES           reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    DIVIDE          reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    PLUS            reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    MINUS           reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    COMMA           reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    EQUALS          reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    RPAREN          reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    GREATER         reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    GREATER_EQ      reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    LESSER          reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    LESSER_EQ       reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    COMPARE         reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    DIFFERENT       reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    SEMI            reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    RBRACK          reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    AND             reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    OR              reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    TO              reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)
    DO              reduce using rule 121 (factor -> ID call LPAREN RPAREN confirm .)


state 259

    (29) declare_fun -> FUNCTION return_type addtype ID addfun LPAREN paramstatus params . paramstatus RPAREN
    (35) paramstatus -> .

    RPAREN          reduce using rule 35 (paramstatus -> .)

    paramstatus                    shift and go to state 269

state 260

    (36) params -> type . addtype COLON multivars
    (37) params -> type . addtype COLON multivars SEMI params
    (16) addtype -> .

    COLON           reduce using rule 16 (addtype -> .)

    addtype                        shift and go to state 270

state 261

    (1) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY . endfunc
    (34) endfunc -> .

    $end            reduce using rule 34 (endfunc -> .)

    endfunc                        shift and go to state 271

state 262

    (2) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc .

    $end            reduce using rule 2 (program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc .)


state 263

    (3) program_structure -> PROGRAM initiate ID addfun addprog SEMI changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc .

    $end            reduce using rule 3 (program_structure -> PROGRAM initiate ID addfun addprog SEMI changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc .)


state 264

    (54) assign -> ID pushid LBRACK exprs RBRACK verif EQUALS . exprs assignment SEMI
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 272
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 265

    (75) decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY . statutes RCURLY filljump
    (76) decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY . statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    statutes                       shift and go to state 273
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 266

    (80) conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO . LCURLY statutes RCURLY endquad

    LCURLY          shift and go to state 274


state 267

    (94) nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO . exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (99) exprs -> . expr pams
    (100) exprs -> . expr pams COMMA exprs
    (101) exprs -> . exprp pams
    (102) exprs -> . exprp pams COMMA exprs
    (105) expr -> . expr PLUS pushop term quad1
    (106) expr -> . expr MINUS pushop term quad1
    (107) expr -> . term quad1
    (103) exprp -> . LPAREN pushop exprs RPAREN popop
    (108) term -> . term TIMES pushop factor quad2
    (109) term -> . term DIVIDE pushop factor quad2
    (110) term -> . factor quad2
    (114) factor -> . C_INT pushint
    (115) factor -> . MINUS C_INT pushintn
    (116) factor -> . C_FLOAT pushfloat
    (117) factor -> . MINUS C_FLOAT pushfloatn
    (118) factor -> . C_CHAR pushchar
    (119) factor -> . ID pushid
    (120) factor -> . ID pushid LBRACK expr RBRACK verif
    (121) factor -> . ID call LPAREN RPAREN confirm
    (122) factor -> . ID call exprp confirm
    (123) factor -> . special1 exprp sconfirm1
    (124) special1 -> . MEDIA
    (125) special1 -> . MODA
    (126) special1 -> . VARIANZA

    LPAREN          shift and go to state 75
    C_INT           shift and go to state 87
    MINUS           shift and go to state 85
    C_FLOAT         shift and go to state 88
    C_CHAR          shift and go to state 89
    ID              shift and go to state 90
    MEDIA           shift and go to state 92
    MODA            shift and go to state 93
    VARIANZA        shift and go to state 94

    exprs                          shift and go to state 275
    expr                           shift and go to state 82
    exprp                          shift and go to state 83
    term                           shift and go to state 84
    factor                         shift and go to state 86
    special1                       shift and go to state 91

state 268

    (120) factor -> ID pushid LBRACK expr RBRACK verif .

    TIMES           reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    DIVIDE          reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    PLUS            reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    MINUS           reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    COMMA           reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    EQUALS          reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    RPAREN          reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    GREATER         reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    GREATER_EQ      reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    LESSER          reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    LESSER_EQ       reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    COMPARE         reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    DIFFERENT       reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    SEMI            reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    RBRACK          reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    AND             reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    OR              reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    TO              reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)
    DO              reduce using rule 120 (factor -> ID pushid LBRACK expr RBRACK verif .)


state 269

    (29) declare_fun -> FUNCTION return_type addtype ID addfun LPAREN paramstatus params paramstatus . RPAREN

    RPAREN          shift and go to state 276


state 270

    (36) params -> type addtype . COLON multivars
    (37) params -> type addtype . COLON multivars SEMI params

    COLON           shift and go to state 277


state 271

    (1) program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc .

    $end            reduce using rule 1 (program_structure -> PROGRAM initiate ID addfun addprog SEMI declare_var changescope functions MAIN changeback LPAREN RPAREN LCURLY statutes RCURLY endfunc .)


state 272

    (54) assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs . assignment SEMI
    (55) assignment -> .

    SEMI            reduce using rule 55 (assignment -> .)

    assignment                     shift and go to state 278

state 273

    (75) decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes . RCURLY filljump
    (76) decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes . RCURLY ELSE elsequad LCURLY statutes RCURLY filljump

    RCURLY          shift and go to state 279


state 274

    (80) conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY . statutes RCURLY endquad
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    statutes                       shift and go to state 280
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 275

    (94) nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs . forquad3 DO LCURLY statutes RCURLY forquad4
    (97) forquad3 -> .

    DO              reduce using rule 97 (forquad3 -> .)

    forquad3                       shift and go to state 281

state 276

    (29) declare_fun -> FUNCTION return_type addtype ID addfun LPAREN paramstatus params paramstatus RPAREN .

    LCURLY          reduce using rule 29 (declare_fun -> FUNCTION return_type addtype ID addfun LPAREN paramstatus params paramstatus RPAREN .)
    VARS            reduce using rule 29 (declare_fun -> FUNCTION return_type addtype ID addfun LPAREN paramstatus params paramstatus RPAREN .)


state 277

    (36) params -> type addtype COLON . multivars
    (37) params -> type addtype COLON . multivars SEMI params
    (17) multivars -> . ID addvar
    (18) multivars -> . ID addvar COMMA multivars
    (19) multivars -> . dimvars addvard
    (20) multivars -> . dimvars addvard COMMA multivars
    (21) dimvars -> . ID LBRACK expr RBRACK

    ID              shift and go to state 98

    multivars                      shift and go to state 282
    dimvars                        shift and go to state 99

state 278

    (54) assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment . SEMI

    SEMI            shift and go to state 283


state 279

    (75) decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY . filljump
    (76) decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY . ELSE elsequad LCURLY statutes RCURLY filljump
    (79) filljump -> .

    ELSE            shift and go to state 285
    ID              reduce using rule 79 (filljump -> .)
    RETURN          reduce using rule 79 (filljump -> .)
    READ            reduce using rule 79 (filljump -> .)
    WRITE           reduce using rule 79 (filljump -> .)
    IF              reduce using rule 79 (filljump -> .)
    WHILE           reduce using rule 79 (filljump -> .)
    FOR             reduce using rule 79 (filljump -> .)
    REGRESION       reduce using rule 79 (filljump -> .)
    PLOT            reduce using rule 79 (filljump -> .)
    RCURLY          reduce using rule 79 (filljump -> .)

    filljump                       shift and go to state 284

state 280

    (80) conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes . RCURLY endquad

    RCURLY          shift and go to state 286


state 281

    (94) nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 . DO LCURLY statutes RCURLY forquad4

    DO              shift and go to state 287


state 282

    (36) params -> type addtype COLON multivars .
    (37) params -> type addtype COLON multivars . SEMI params

    RPAREN          reduce using rule 36 (params -> type addtype COLON multivars .)
    SEMI            shift and go to state 288


state 283

    (54) assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI .

    ID              reduce using rule 54 (assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI .)
    RETURN          reduce using rule 54 (assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI .)
    READ            reduce using rule 54 (assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI .)
    WRITE           reduce using rule 54 (assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI .)
    IF              reduce using rule 54 (assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI .)
    WHILE           reduce using rule 54 (assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI .)
    FOR             reduce using rule 54 (assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI .)
    REGRESION       reduce using rule 54 (assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI .)
    PLOT            reduce using rule 54 (assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI .)
    RCURLY          reduce using rule 54 (assign -> ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI .)


state 284

    (75) decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump .

    ID              reduce using rule 75 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump .)
    RETURN          reduce using rule 75 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump .)
    READ            reduce using rule 75 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump .)
    WRITE           reduce using rule 75 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump .)
    IF              reduce using rule 75 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump .)
    WHILE           reduce using rule 75 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump .)
    FOR             reduce using rule 75 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump .)
    REGRESION       reduce using rule 75 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump .)
    PLOT            reduce using rule 75 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump .)
    RCURLY          reduce using rule 75 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump .)


state 285

    (76) decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE . elsequad LCURLY statutes RCURLY filljump
    (78) elsequad -> .

    LCURLY          reduce using rule 78 (elsequad -> .)

    elsequad                       shift and go to state 289

state 286

    (80) conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY . endquad
    (83) endquad -> .

    ID              reduce using rule 83 (endquad -> .)
    RETURN          reduce using rule 83 (endquad -> .)
    READ            reduce using rule 83 (endquad -> .)
    WRITE           reduce using rule 83 (endquad -> .)
    IF              reduce using rule 83 (endquad -> .)
    WHILE           reduce using rule 83 (endquad -> .)
    FOR             reduce using rule 83 (endquad -> .)
    REGRESION       reduce using rule 83 (endquad -> .)
    PLOT            reduce using rule 83 (endquad -> .)
    RCURLY          reduce using rule 83 (endquad -> .)

    endquad                        shift and go to state 290

state 287

    (94) nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO . LCURLY statutes RCURLY forquad4

    LCURLY          shift and go to state 291


state 288

    (37) params -> type addtype COLON multivars SEMI . params
    (36) params -> . type addtype COLON multivars
    (37) params -> . type addtype COLON multivars SEMI params
    (10) type -> . INT
    (11) type -> . FLOAT
    (12) type -> . CHAR

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    CHAR            shift and go to state 21

    type                           shift and go to state 260
    params                         shift and go to state 292

state 289

    (76) decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad . LCURLY statutes RCURLY filljump

    LCURLY          shift and go to state 293


state 290

    (80) conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad .

    ID              reduce using rule 80 (conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad .)
    RETURN          reduce using rule 80 (conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad .)
    READ            reduce using rule 80 (conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad .)
    WRITE           reduce using rule 80 (conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad .)
    IF              reduce using rule 80 (conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad .)
    WHILE           reduce using rule 80 (conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad .)
    FOR             reduce using rule 80 (conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad .)
    REGRESION       reduce using rule 80 (conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad .)
    PLOT            reduce using rule 80 (conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad .)
    RCURLY          reduce using rule 80 (conditional -> WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad .)


state 291

    (94) nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY . statutes RCURLY forquad4
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    statutes                       shift and go to state 294
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 292

    (37) params -> type addtype COLON multivars SEMI params .

    RPAREN          reduce using rule 37 (params -> type addtype COLON multivars SEMI params .)


state 293

    (76) decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY . statutes RCURLY filljump
    (38) statutes -> . assign
    (39) statutes -> . assign statutes
    (40) statutes -> . call_void
    (41) statutes -> . call_void statutes
    (42) statutes -> . returning
    (43) statutes -> . reading
    (44) statutes -> . reading statutes
    (45) statutes -> . writing
    (46) statutes -> . writing statutes
    (47) statutes -> . decision
    (48) statutes -> . decision statutes
    (49) statutes -> . conditional
    (50) statutes -> . conditional statutes
    (51) statutes -> . nonconditional
    (52) statutes -> . nonconditional statutes
    (53) assign -> . ID pushid EQUALS exprs assignment SEMI
    (54) assign -> . ID pushid LBRACK exprs RBRACK verif EQUALS exprs assignment SEMI
    (56) call_void -> . ID call exprp confirm SEMI
    (57) call_void -> . ID call LPAREN RPAREN confirm SEMI
    (58) call_void -> . special2 exprp sconfirm2 SEMI
    (62) returning -> . RETURN LPAREN exprs returnquad RPAREN SEMI
    (64) reading -> . READ LPAREN read_opt RPAREN SEMI
    (68) writing -> . WRITE LPAREN write_opt RPAREN SEMI
    (75) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY filljump
    (76) decision -> . IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump
    (80) conditional -> . WHILE loopquad LPAREN logic RPAREN whilequad DO LCURLY statutes RCURLY endquad
    (94) nonconditional -> . FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4
    (59) special2 -> . REGRESION
    (60) special2 -> . PLOT

    ID              shift and go to state 47
    RETURN          shift and go to state 49
    READ            shift and go to state 50
    WRITE           shift and go to state 51
    IF              shift and go to state 52
    WHILE           shift and go to state 53
    FOR             shift and go to state 54
    REGRESION       shift and go to state 55
    PLOT            shift and go to state 56

    statutes                       shift and go to state 295
    assign                         shift and go to state 39
    call_void                      shift and go to state 40
    returning                      shift and go to state 41
    reading                        shift and go to state 42
    writing                        shift and go to state 43
    decision                       shift and go to state 44
    conditional                    shift and go to state 45
    nonconditional                 shift and go to state 46
    special2                       shift and go to state 48

state 294

    (94) nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes . RCURLY forquad4

    RCURLY          shift and go to state 296


state 295

    (76) decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes . RCURLY filljump

    RCURLY          shift and go to state 297


state 296

    (94) nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY . forquad4
    (98) forquad4 -> .

    ID              reduce using rule 98 (forquad4 -> .)
    RETURN          reduce using rule 98 (forquad4 -> .)
    READ            reduce using rule 98 (forquad4 -> .)
    WRITE           reduce using rule 98 (forquad4 -> .)
    IF              reduce using rule 98 (forquad4 -> .)
    WHILE           reduce using rule 98 (forquad4 -> .)
    FOR             reduce using rule 98 (forquad4 -> .)
    REGRESION       reduce using rule 98 (forquad4 -> .)
    PLOT            reduce using rule 98 (forquad4 -> .)
    RCURLY          reduce using rule 98 (forquad4 -> .)

    forquad4                       shift and go to state 298

state 297

    (76) decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY . filljump
    (79) filljump -> .

    ID              reduce using rule 79 (filljump -> .)
    RETURN          reduce using rule 79 (filljump -> .)
    READ            reduce using rule 79 (filljump -> .)
    WRITE           reduce using rule 79 (filljump -> .)
    IF              reduce using rule 79 (filljump -> .)
    WHILE           reduce using rule 79 (filljump -> .)
    FOR             reduce using rule 79 (filljump -> .)
    REGRESION       reduce using rule 79 (filljump -> .)
    PLOT            reduce using rule 79 (filljump -> .)
    RCURLY          reduce using rule 79 (filljump -> .)

    filljump                       shift and go to state 299

state 298

    (94) nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4 .

    ID              reduce using rule 94 (nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4 .)
    RETURN          reduce using rule 94 (nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4 .)
    READ            reduce using rule 94 (nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4 .)
    WRITE           reduce using rule 94 (nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4 .)
    IF              reduce using rule 94 (nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4 .)
    WHILE           reduce using rule 94 (nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4 .)
    FOR             reduce using rule 94 (nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4 .)
    REGRESION       reduce using rule 94 (nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4 .)
    PLOT            reduce using rule 94 (nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4 .)
    RCURLY          reduce using rule 94 (nonconditional -> FOR exprs forquad1 EQUALS exprs forquad2 TO exprs forquad3 DO LCURLY statutes RCURLY forquad4 .)


state 299

    (76) decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump .

    ID              reduce using rule 76 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump .)
    RETURN          reduce using rule 76 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump .)
    READ            reduce using rule 76 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump .)
    WRITE           reduce using rule 76 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump .)
    IF              reduce using rule 76 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump .)
    WHILE           reduce using rule 76 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump .)
    FOR             reduce using rule 76 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump .)
    REGRESION       reduce using rule 76 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump .)
    PLOT            reduce using rule 76 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump .)
    RCURLY          reduce using rule 76 (decision -> IF LPAREN logic RPAREN ifquad THEN LCURLY statutes RCURLY ELSE elsequad LCURLY statutes RCURLY filljump .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 122 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 125 resolved as shift
